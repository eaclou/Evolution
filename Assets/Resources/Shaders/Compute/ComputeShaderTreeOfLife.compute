// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSTick  // update positions, increment age, fake n-body sim
// Copy?
#pragma kernel CSAddNewSpeciesNode
#pragma kernel CSAddNewSpeciesStemSegments
#pragma kernel CSExctinctSpecies
#pragma kernel CSGetNodeColliderData
#pragma kernel CSPinRootNode

#include "Assets/Resources/Shaders/Inc/StructsTreeOfLife.cginc"
//#include "Assets/Resources/Shaders/Inc/TreeOfLife.cginc"
#include "Assets/Resources/Shaders/Inc/NoiseShared.cginc"

StructuredBuffer<TreeOfLifeNodeColliderData> treeOfLifeNodeColliderDataCBufferRead;
RWStructuredBuffer<TreeOfLifeNodeColliderData> treeOfLifeNodeColliderDataCBufferWrite;
RWStructuredBuffer<TreeOfLifeLeafNodeData> treeOfLifeLeafNodeDataCBuffer;
RWStructuredBuffer<TreeOfLifeStemSegmentData> treeOfLifeStemSegmentDataCBuffer;

StructuredBuffer<int> speciesIndexCBuffer;
StructuredBuffer<TreeOfLifeLeafNodeData> updateSpeciesNodeDataCBuffer;
StructuredBuffer<TreeOfLifeStemSegmentData> updateStemSegmentDataCBuffer;

uniform int _UpdateBufferStartIndex;

uniform float4 _InputForceUI;

uniform float4 _TopLeftCornerWorldPos;
uniform float4 _CamRightDir;
uniform float4 _CamUpDir;
uniform float _CamScale;

uniform int _HoverID;
uniform int _SelectedID;
uniform float _IsDragging;
uniform float4 _DraggingForceVector;
uniform int _CurDeepestGraphDepth;

uniform float _Time;

[numthreads(512,1,1)]
void CSTick (uint3 id : SV_DispatchThreadID)
{
	// Repel / Re-Position
	TreeOfLifeNodeColliderData colliderData = treeOfLifeNodeColliderDataCBufferRead[id.x];
	TreeOfLifeLeafNodeData leafNodeData = treeOfLifeLeafNodeDataCBuffer[id.x];
	
	int maxNumSpecies = 512 - 1;

	float selfIsSelectedMask = saturate(1.0 - saturate(abs((float)_SelectedID - (float)id.x)));
	float decayRepelBonus = leafNodeData.decayPercentage;
	// compare to nearest neighbors:
	float3 ownPos = colliderData.localPos;
	float3 repelForce = float3(0,0,0);

	for(int i = 0; i < 32; i++) {
		int neighborIndex = min(max(0, i - 15), maxNumSpecies);
		float3 neighborPos = treeOfLifeNodeColliderDataCBufferRead[neighborIndex].localPos;

		float neighborStatusMask = 1.0 - treeOfLifeLeafNodeDataCBuffer[neighborIndex].isExtinct;
		float selectedMask = saturate(1.0 - saturate(abs((float)_SelectedID - (float)neighborIndex)));
		float repelMultiplier = neighborStatusMask + selectedMask * 1.5 + decayRepelBonus * 2.15;
		// If neighbor is hover/selected -- provide more repel force?

		float3 vecToNeighbor = neighborPos - ownPos;
		
		float dist = length(vecToNeighbor);
		if(dist < (leafNodeData.age * 0.75 + selectedMask * 0.75)) {
			repelForce += vecToNeighbor * -0.00025 * repelMultiplier * (1.0 / max(dist * dist, 0.005));

			if(dist < 0.005) {
				repelForce += ((float)neighborIndex - (float)id.x) * 0.017;
			}
		}
		//repelForce *= neighborStatusMask;
	}

	float2 vecFromAxis = float2(ownPos.x, ownPos.z);
	float distToAxis = length(vecFromAxis);
	//repelForce.xz += (normalize(vecFromAxis) * (1.0 / max(distToAxis * distToAxis, 0.1)) * 0.01) * decayRepelBonus;

	// AttractForce:
	float normalizedMaxGraphDepth = max(3.0, (float)_CurDeepestGraphDepth);
	float targetDepth = (float)leafNodeData.graphDepth * 3.6 / normalizedMaxGraphDepth + selfIsSelectedMask * 0.1;
	float3 targetPos = float3(targetDepth, treeOfLifeNodeColliderDataCBufferRead[leafNodeData.parentSpeciesID].localPos.y - (leafNodeData.isExtinct * 0.05) + ((float)leafNodeData.graphDepth / ((float)_CurDeepestGraphDepth + 1.0) - 0.14) * 0.35 + 0.15, 0.0);
	float3 vecToTarget = targetPos - ownPos;
	float3 attractForce = vecToTarget * 0.00231;
	attractForce.y *= 0.5;
	repelForce.y *= 1.25;

	float3 noiseForce = Value3D(float3(_Time, _Time, _Time) * 0.8973412 + float3((float)id.x, (float)id.x, (float)id.x) * 33, 0.567).yzw;
	colliderData.localPos += noiseForce * 0.00015 * (1.0 - leafNodeData.decayPercentage);
	colliderData.localPos += (repelForce + attractForce) * (1.1 - leafNodeData.isExtinct);
	float topOfScreenRepel = saturate(colliderData.localPos.y - 0.15) * 16;
	colliderData.localPos.y -= topOfScreenRepel;
	colliderData.localPos *= leafNodeData.isActive;

	colliderData.localPos.xy += _DraggingForceVector.xy * (_IsDragging * 0.0033) * selfIsSelectedMask;
		
	treeOfLifeNodeColliderDataCBufferWrite[id.x] = colliderData;

	//treeOfLifeNodeColliderDataCBuffer[0].localPos = float3(0,0,0); // *** REFACTOR!!!! ***
		
	// Increment Age
	leafNodeData.age = saturate(leafNodeData.age + 0.00125);
	leafNodeData.decayPercentage = saturate(leafNodeData.decayPercentage + 0.0005 * leafNodeData.isExtinct);
	treeOfLifeLeafNodeDataCBuffer[id.x] = leafNodeData;
}

[numthreads(1,1,1)]
void CSAddNewSpeciesNode (uint3 id : SV_DispatchThreadID)
{
	int speciesID = speciesIndexCBuffer[id.x];	
	treeOfLifeLeafNodeDataCBuffer[speciesID] = updateSpeciesNodeDataCBuffer[0];
	
	int parentSpeciesID = treeOfLifeLeafNodeDataCBuffer[speciesID].parentSpeciesID;
	float3 parentLocalPos = treeOfLifeNodeColliderDataCBufferWrite[parentSpeciesID].localPos;
	float initOffsetY = frac(sin(dot(float2((float)speciesID, (float)parentSpeciesID) ,float2(12.9898,78.233))) * 43758.5453) - 0.5;   // -0.5 --> +0.5
	treeOfLifeNodeColliderDataCBufferWrite[speciesID].localPos = float3(parentLocalPos.x + 0.015, parentLocalPos.y - initOffsetY * 0.025, parentLocalPos.z - (float)speciesID * 0.00025);
		
}

[numthreads(1,1,1)]
void CSAddNewSpeciesStemSegments (uint3 id : SV_DispatchThreadID)
{
	int stemSegmentIndex = _UpdateBufferStartIndex + id.x;	treeOfLifeStemSegmentDataCBuffer[stemSegmentIndex] = updateStemSegmentDataCBuffer[id.x];
	
}

[numthreads(1,1,1)]
void CSExctinctSpecies (uint3 id : SV_DispatchThreadID)
{
	int speciesID = speciesIndexCBuffer[id.x];	
	treeOfLifeLeafNodeDataCBuffer[speciesID].isExtinct = updateSpeciesNodeDataCBuffer[id.x].isExtinct;	
}

[numthreads(1,1,1)]
void CSGetNodeColliderData (uint3 id : SV_DispatchThreadID)
{
	
}

[numthreads(1,1,1)]
void CSPinRootNode (uint3 id : SV_DispatchThreadID)
{
	treeOfLifeNodeColliderDataCBufferWrite[0].localPos = float3(0,0,0);
}

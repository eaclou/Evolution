// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSUpdateGroundStrokes
#pragma kernel CSGetObjectDepths
#pragma kernel CSGenerateMeshData
#pragma kernel CSGenerateTriangleIndices
#pragma kernel CSSimDecomposerBitsData
#pragma kernel CSSimWasteBitsData

struct TriangleIndexData {
    int v1;
    int v2;
    int v3;
};

struct GroundBitsData
{
	int index;
	float3 worldPos;
	float2 heading;
	float2 localScale;
	float age;
	float speed;
	float noiseVal;
	float isActive;
	int brushType;
};

struct FrameBufferStrokeData {
	float3 worldPos;
	float2 scale;
	float2 heading;
	int brushType;
};

#include "Assets/Resources/Shaders/Inc/NoiseShared.cginc"

StructuredBuffer<float4> ObjectPositionsCBuffer;
RWStructuredBuffer<float3> DepthValuesCBuffer;

//Texture2D<float4> heightTexture;
RWStructuredBuffer<float3> terrainVertexCBuffer;
RWStructuredBuffer<float2> terrainUVCBuffer;
RWStructuredBuffer<float3> terrainNormalCBuffer;
RWStructuredBuffer<float4> terrainColorCBuffer;
RWStructuredBuffer<TriangleIndexData> terrainTriangleCBuffer;

RWStructuredBuffer<GroundBitsData> groundBitsCBuffer;

RWStructuredBuffer<FrameBufferStrokeData> terrainFrameBufferStrokesCBuffer;

Texture2D<float4> VelocityRead;
Texture2D<float4> AltitudeRead;

Texture2D<float4> _ResourceGridRead;

int _MeshResolution = 32;

float4 _QuadBounds;  // xy = min, zw = max
float2 _HeightRange;

uniform float _CamDistNormalized;
uniform float4 _SpawnBoundsCameraDetails;

uniform float _TextureResolution;
uniform float _DeltaTime;
uniform float _InvGridScale;
uniform float _MapSize;

uniform float _Time;

uniform float4 _SpawnPos;
uniform float _SpawnRadius;
uniform float _DecomposerDensityLerp;

uniform float _BrushAlignment = 1.0;


SamplerState _LinearClamp;
SamplerState _LinearRepeat;
SamplerState _PointClamp;
SamplerState _PointRepeat;

float rand(float2 co){   // OUTPUT is in [0,1] RANGE!!!
	return frac(sin(dot(co.xy ,float2(12.9898,78.233))) * 43758.5453);
}

[numthreads(1,1,1)]
void CSUpdateGroundStrokes (uint3 id : SV_DispatchThreadID)
{
	FrameBufferStrokeData data = terrainFrameBufferStrokesCBuffer[id.x];

	// find uv for sampling terrainHeightMap

	float2 uv = data.worldPos.xy / _MapSize;
	float pixelOffset = 1.0 / 128;  // resolution

	float4 altitudeSampleCenter = AltitudeRead.SampleLevel(_LinearClamp, uv, 0);
	float4 altitudeSampleNorth = AltitudeRead.SampleLevel(_LinearClamp, uv + float2(0, pixelOffset), 0);
	float4 altitudeSampleEast = AltitudeRead.SampleLevel(_LinearClamp, uv + float2(pixelOffset, 0), 0);
	float4 altitudeSampleSouth = AltitudeRead.SampleLevel(_LinearClamp, uv + float2(0, -pixelOffset), 0);
	float4 altitudeSampleWest = AltitudeRead.SampleLevel(_LinearClamp, uv + float2(-pixelOffset, 0), 0);

	float altitudeCenter = altitudeSampleCenter.x;
	float altitudeNorth = altitudeSampleNorth.x;
	float altitudeEast = altitudeSampleEast.x;
	float altitudeSouth = altitudeSampleSouth.x;
	float altitudeWest = altitudeSampleWest.x;

	float dX = altitudeEast - altitudeWest;
	float dY = altitudeNorth - altitudeSouth;

	float2 gradDir = float2(dX,dY); 
	float2 topoDir = float2(dY,-dX);
	float randAngle = Value2D(uv, 1000).x * 6.28;
	float2 randDir = float2(cos(randAngle), sin(randAngle));

	float2 heading = lerp(gradDir, randDir, altitudeSampleCenter.y);
	heading = lerp(heading, randDir, altitudeSampleCenter.z);
	heading = lerp(heading, topoDir, altitudeSampleCenter.w);
	
	if(heading.x != 0 && heading.y != 0) {
		heading = normalize(heading);
	}
	else {
		heading = normalize(randDir);
	}

	// New code:
	// Brushstrokes vary in:  (heading, brush alpha)
	
	terrainFrameBufferStrokesCBuffer[id.x].heading = heading;
	terrainFrameBufferStrokesCBuffer[id.x].worldPos.z = -altitudeCenter * 20 + 10;
}

[numthreads(1,1,1)]
void CSGetObjectDepths (uint3 id : SV_DispatchThreadID)
{				
	float4 data = ObjectPositionsCBuffer[id.x];
	
	float2 uv = data.xy;
	float2 uvOffset = data.zw;
	
	float depthCenter = AltitudeRead.SampleLevel(_LinearRepeat, uv, 0).x;
	float depthLeft = AltitudeRead.SampleLevel(_LinearRepeat, uv + float2(-uvOffset.x, 0), 0).x;
	float depthRight = AltitudeRead.SampleLevel(_LinearRepeat, uv + float2(uvOffset.x, 0), 0).x;
	float depthUp = AltitudeRead.SampleLevel(_LinearRepeat, uv + float2(0, uvOffset.y), 0).x;
	float depthDown = AltitudeRead.SampleLevel(_LinearRepeat, uv + float2(0, -uvOffset.y), 0).x;

	float2 grad = float2(depthRight - depthLeft, depthUp - depthDown);

	float3 depth = float3(1.0 - saturate(depthCenter * 2.0), -grad); // (velLeft + velRight + velUp + velDown) / 4;

	DepthValuesCBuffer[id.x] = depth;
}

[numthreads(1024,1,1)]
void CSSimDecomposerBitsData (uint3 id : SV_DispatchThreadID)
{	
	GroundBitsData decomposerBitData = groundBitsCBuffer[id.x];

	if(decomposerBitData.isActive > 0.5) {  // ALIVE!
		
		float2 uv = decomposerBitData.worldPos.xy / _MapSize;		
		float altitude = AltitudeRead.SampleLevel(_LinearClamp, uv, 0).x;
		
		decomposerBitData.age = decomposerBitData.age + 0.0065;  // ? frame lifespan

		// if should be killed:
		if(decomposerBitData.age > 1.0) {
			decomposerBitData.isActive = 0;
			// age resetting happens at birth	
		}
		else {
			
			float2 vel = VelocityRead.SampleLevel(_LinearRepeat, uv, 0).xy;
			float speedMult = 0.0075;

			decomposerBitData.speed = length(vel);
	
			float2 nextPos = uv + vel * speedMult;
			
			float pixelOffset = 1.0 / 256;  // resolution  // **** THIS CAN"T BE HARDCODED AS FINAL ****"

			float altitudeCenter = AltitudeRead.SampleLevel(_LinearClamp, uv, 0).x;
			float altitudeNorth = AltitudeRead.SampleLevel(_LinearClamp, uv + float2(0, pixelOffset), 0).x;
			float altitudeEast = AltitudeRead.SampleLevel(_LinearClamp, uv + float2(pixelOffset, 0), 0).x;
			float altitudeSouth = AltitudeRead.SampleLevel(_LinearClamp, uv + float2(0, -pixelOffset), 0).x;
			float altitudeWest = AltitudeRead.SampleLevel(_LinearClamp, uv + float2(-pixelOffset, 0), 0).x;

			float dX = altitudeEast - altitudeWest;
			float dY = altitudeNorth - altitudeSouth;

			float2 grad = float2(0,1);
			if(dX != 0 && dY != 0) {
				grad = normalize(lerp(float2(dX, dY), float2(0,1), 0.5));
			}
		
			decomposerBitData.heading = grad;
			decomposerBitData.worldPos = float3(nextPos * _MapSize, 0);		
		}
	}
	else { // DEAD / INACTIVE:::
		
		// check potential spawn location:
		float2 spawnUV = float2(rand(float2(id.x, _Time * 120)), rand(float2(-_Time, id.x + _Time * 89.913)));
				
		//float spawnAltitude = AltitudeRead.SampleLevel(_LinearClamp, spawnUV, 0).x;

		float2 spawnPos = spawnUV * _MapSize;
		
		float noiseFreq = 4.2;
		float spawnNoise1 = Value2D(spawnPos + 5, noiseFreq * 0.2755).x;
		float spawnNoise2 = Value2D(spawnPos - 33, noiseFreq * 0.3254).x;
		float spawnNoise3 = saturate(Value2D(spawnPos + 349.7, 2.4579).x * 2.5);
		//float altitudeMask = saturate((1 - spawnAltitude) * 4);
		
		// Try respawning:
		float4 resourceGridSample = _ResourceGridRead.SampleLevel(_LinearClamp, spawnUV, 0);  // ** actually the resourceGrid Tex -- rename
		float spawnRating = resourceGridSample.z;

		float distToOrigin = length(_SpawnPos.xy - (spawnUV * _MapSize));
		if(spawnRating > 0.025) {			
			spawnPos += float2(spawnNoise1, spawnNoise2) * 0.93416;		
			decomposerBitData.worldPos = float3(spawnPos, 0);
			decomposerBitData.age = decomposerBitData.age % 1.0;
			decomposerBitData.isActive = 1.0;
		}		
	}
	
	groundBitsCBuffer[id.x] = decomposerBitData;
	
}

[numthreads(1024,1,1)]
void CSSimWasteBitsData (uint3 id : SV_DispatchThreadID)
{	
	GroundBitsData wasteBitData = groundBitsCBuffer[id.x];

	if(wasteBitData.isActive > 0.5) {  // ALIVE!
		
		
	
		if(wasteBitData.age > 1.0) {  // OLD AGE DEATH:::
			wasteBitData.isActive = 0.0;			

		}
		else {   // ALIVE && ACTIVE
			float2 uv = wasteBitData.worldPos.xy / _MapSize;		
			float altitude = AltitudeRead.SampleLevel(_LinearClamp, uv, 0).x;
			float2 vel = VelocityRead.SampleLevel(_LinearClamp, uv, 0).xy;
			float speedMult = 0.0;
			wasteBitData.speed = length(vel);
	
			float2 nextPos = uv + vel * speedMult;


			wasteBitData.age = wasteBitData.age + 0.0045;  // ? frame lifespan
			wasteBitData.worldPos = float3(nextPos * _MapSize, 0);		
		}


	}
	else {  // INACTIVE::::
	
		//float2 spawnPos = float2(rand(float2(id.x, _Time * 120)), rand(float2(-_Time, id.x + _Time * 89.913)));		
		//float2 spawnBoxSize = float2(_SpawnBoundsCameraDetails.z - _SpawnBoundsCameraDetails.x, _SpawnBoundsCameraDetails.w - _SpawnBoundsCameraDetails.y);
		//spawnPos = spawnPos * spawnBoxSize + _SpawnBoundsCameraDetails.xy;
		
		// check potential spawn location:
		float2 spawnUV = float2(rand(float2(id.x, _Time * 120)), rand(float2(-_Time, id.x + _Time * 89.913)));
		float2 spawnPos = spawnUV * _MapSize;
		
		float noiseFreq = 4.2;
		float spawnNoise1 = Value2D(spawnPos + 5, noiseFreq * 0.2755).x;
		float spawnNoise2 = Value2D(spawnPos - 33, noiseFreq * 0.3254).x;
		
		// Try respawning:
		float4 resourceGridSample = _ResourceGridRead.SampleLevel(_LinearClamp, spawnUV, 0);  // ** actually the resourceGrid Tex -- rename
		float spawnRating = resourceGridSample.y;  // WASTE

		float distToOrigin = length(_SpawnPos.xy - (spawnUV * _MapSize));
		if(spawnRating > 0.025) {			
			spawnPos += float2(spawnNoise1, spawnNoise2) * 0.93416;		
			wasteBitData.worldPos = float3(spawnPos, 0);
			wasteBitData.age = wasteBitData.age % 1.0;
			wasteBitData.heading = normalize(float2(spawnNoise1, spawnNoise2));
			wasteBitData.isActive = 1.0;
			
		}	
	}
	
	groundBitsCBuffer[id.x] = wasteBitData;
	
}

[numthreads(1,1,1)]
void CSGenerateMeshData (uint3 id : SV_DispatchThreadID)
{
	int index = id.x * _MeshResolution + id.z;

	float xRange = _QuadBounds.y - _QuadBounds.x;
	float zRange = _QuadBounds.w - _QuadBounds.z;
	float xPart = (float)id.x / (float)(_MeshResolution - 1);
	float zPart = (float)id.z / (float)(_MeshResolution - 1);
	float x = xPart * xRange + _QuadBounds.x;
	float z = zPart * zRange + _QuadBounds.z;  // worldCoords
		
	float2 uv = float2(xPart,zPart);
	
	float4 textureSample =  AltitudeRead.SampleLevel(_LinearClamp, uv, 0);

	float heightRange = _HeightRange.y - _HeightRange.x;
	float height = (1.0 - textureSample.x) * heightRange + _HeightRange.x;
	
	terrainVertexCBuffer[index] = float3(x, z, height);
	terrainUVCBuffer[index] = uv;
	terrainNormalCBuffer[index] = float3(0,0,1);

	//COLOR:	
	terrainColorCBuffer[index] = float4(1, 1, 1, 1);	
}

[numthreads(1,1,1)]
void CSGenerateTriangleIndices (uint3 id : SV_DispatchThreadID)
{
	TriangleIndexData triangleIndexData0;
	TriangleIndexData triangleIndexData1;

	int index0 = (id.x * (_MeshResolution - 1) + id.z) * 2;
	int index1 = index0 + 1;

	int v00 = id.x * _MeshResolution + id.z;
	int v10 = (id.x + 1) * _MeshResolution + id.z;
	int v01 = id.x * _MeshResolution + (id.z + 1);
	int v11 = (id.x + 1) * _MeshResolution + (id.z + 1);

	triangleIndexData0.v1 = v00;
	triangleIndexData0.v2 = v01;
	triangleIndexData0.v3 = v11;

	triangleIndexData1.v1 = v00;
	triangleIndexData1.v2 = v11;
	triangleIndexData1.v3 = v10;

	terrainTriangleCBuffer[index0] = triangleIndexData0;
	terrainTriangleCBuffer[index1] = triangleIndexData1;
}

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSGenerateMeshData
#pragma kernel CSGenerateTriangleIndices
#pragma kernel CSSimGroundBitsData
#pragma kernel CSSimCarpetBitsData

struct TriangleIndexData {
    int v1;
    int v2;
    int v3;
};

struct GroundBitsData
{
	int index;
	float3 worldPos;
	float2 heading;
	float2 localScale;
	float age;
	float speed;
	float noiseVal;
	int brushType;
};

#include "Assets/Resources/Shaders/Inc/NoiseShared.cginc"


Texture2D<float4> heightTexture;
RWStructuredBuffer<float3> terrainVertexCBuffer;
RWStructuredBuffer<float2> terrainUVCBuffer;
RWStructuredBuffer<float3> terrainNormalCBuffer;
RWStructuredBuffer<float4> terrainColorCBuffer;
RWStructuredBuffer<TriangleIndexData> terrainTriangleCBuffer;

RWStructuredBuffer<GroundBitsData> groundBitsCBuffer;

Texture2D<float4> VelocityRead;
Texture2D<float4> AltitudeRead;

int resolutionX = 16;
int resolutionZ = 16;

float4 _QuadBounds;  // xy = min, zw = max
float2 _HeightRange;

uniform float _CamDistNormalized;
uniform float4 _SpawnBoundsCameraDetails;

uniform float _TextureResolution;
uniform float _DeltaTime;
uniform float _InvGridScale;
uniform float _MapSize;

uniform float _Time;

SamplerState _LinearClamp;
SamplerState _LinearRepeat;
SamplerState _PointClamp;
SamplerState _PointRepeat;

float rand(float2 co){   // OUTPUT is in [0,1] RANGE!!!
	return frac(sin(dot(co.xy ,float2(12.9898,78.233))) * 43758.5453);
}

[numthreads(1024,1,1)]
void CSSimGroundBitsData (uint3 id : SV_DispatchThreadID)
{	
	GroundBitsData groundBitData = groundBitsCBuffer[id.x];

	// ***** Move Head Point0: //

	float2 uv = groundBitData.worldPos.xy / _MapSize;
	float2 altitudeUV = uv * 0.5 + 0.25;
	float2 vel = VelocityRead.SampleLevel(_LinearRepeat, uv, 1).xy;
	float speedMult = 0.0075;

	groundBitData.speed = length(vel);
	
	float2 nextPos = uv + vel * speedMult;

	float altitude = AltitudeRead.SampleLevel(_LinearRepeat, altitudeUV, 0).x;

	groundBitData.age = groundBitData.age + 0.0025;  // ? frame lifespan
	if(groundBitData.age > 1.0 || altitude > 0.5 ) {
		
		float2 spawnPos = float2(rand(float2(id.x, uv.x + _Time)), rand(float2(uv.y - _Time, id.x + _Time * 8.913)));		
		float2 spawnBoxSize = float2(_SpawnBoundsCameraDetails.z - _SpawnBoundsCameraDetails.x, _SpawnBoundsCameraDetails.w - _SpawnBoundsCameraDetails.y);
		spawnPos = spawnPos * spawnBoxSize + _SpawnBoundsCameraDetails.xy;

		// check potential spawn location:
		float2 spawnUV = spawnPos / _MapSize;
		float spawnAltitude = AltitudeRead.SampleLevel(_LinearRepeat, spawnUV * 0.5 + 0.25, 0).x;
		float spawnNoise1 = saturate(Value2D(spawnPos + 5, 0.255).x * 10);
		float spawnNoise2 = saturate(Value2D(spawnPos - 33, 0.65).x * 6.5);
		float spawnNoise3 = saturate(Value2D(spawnPos + 349.7, 2.4579).x * 2.5);
		float altitudeMask = (1.0 - saturate(-1.0 * (spawnAltitude * 2.0 - 1.0)));
		
		float spawnRating = spawnNoise2 * spawnNoise3 * altitudeMask; // * spawnNoise * spawnNoise * altitudeMask * altitudeMask;

		if(spawnRating > (float)id.x / 1024.0 / 8.0) {
			groundBitData.worldPos = float3(spawnPos, 0);
			groundBitData.age -= 1;

			// find uv for sampling terrainHeightMap
			float2 uv = spawnPos.xy / _MapSize * 0.5 + 0.25;
			float pixelOffset = 1.0 / 256;  // resolution

			float altitudeCenter = AltitudeRead.SampleLevel(_LinearClamp, uv, 2).x;
			float altitudeNorth = AltitudeRead.SampleLevel(_LinearClamp, uv + float2(0, pixelOffset), 2).x;
			float altitudeEast = AltitudeRead.SampleLevel(_LinearClamp, uv + float2(pixelOffset, 0), 2).x;
			float altitudeSouth = AltitudeRead.SampleLevel(_LinearClamp, uv + float2(0, -pixelOffset), 2).x;
			float altitudeWest = AltitudeRead.SampleLevel(_LinearClamp, uv + float2(-pixelOffset, 0), 2).x;

			float dX = altitudeEast - altitudeWest;
			float dY = altitudeNorth - altitudeSouth;

			float2 grad = float2(0,1);
			if(dX != 0 && dY != 0) {
				grad = normalize(float2(dX, dY));
			}
			//grad = float2(grad.y, -grad.x);

			groundBitData.heading = -grad;
		}
	}
	else {
		groundBitData.worldPos = float3(nextPos * _MapSize, 0);		
	}

	//float2 forwardDir = normalize(vel);
	
	
	groundBitsCBuffer[id.x] = groundBitData;
	
}

[numthreads(1024,1,1)]
void CSSimCarpetBitsData (uint3 id : SV_DispatchThreadID)
{	
	GroundBitsData groundBitData = groundBitsCBuffer[id.x];

	// ***** Move Head Point0: //

	float2 uv = groundBitData.worldPos.xy / _MapSize;
	float2 altitudeUV = uv * 0.5 + 0.25;
	float2 vel = VelocityRead.SampleLevel(_LinearRepeat, uv, 1).xy;
	float speedMult = 0.0075;

	groundBitData.speed = length(vel);
	
	float2 nextPos = uv + vel * speedMult;

	float altitude = AltitudeRead.SampleLevel(_LinearRepeat, altitudeUV, 0).x;

	groundBitData.age = groundBitData.age + 0.0025;  // ? frame lifespan
	if(groundBitData.age > 1.0 || altitude > 0.5 ) {
		
		float2 spawnPos = float2(rand(float2(id.x, uv.x + _Time)), rand(float2(uv.y - _Time, id.x + _Time * 8.913)));		
		float2 spawnBoxSize = float2(_SpawnBoundsCameraDetails.z - _SpawnBoundsCameraDetails.x, _SpawnBoundsCameraDetails.w - _SpawnBoundsCameraDetails.y);
		spawnPos = spawnPos * spawnBoxSize + _SpawnBoundsCameraDetails.xy;

		// check potential spawn location:
		float2 spawnUV = spawnPos / _MapSize;
		float spawnAltitude = AltitudeRead.SampleLevel(_LinearRepeat, spawnUV * 0.5 + 0.25, 0).x;
		float spawnNoise1 = saturate(Value2D(spawnPos + 5, 0.0255).x * 6);
		float spawnNoise2 = saturate(Value2D(spawnPos - 33, 0.35).x * 6.5);
		float spawnNoise3 = saturate(Value2D(spawnPos + 349.7, 0.4579).x * 10);
		float altitudeMask = (1.0 - saturate(-1.0 * (spawnAltitude * 2.0 - 1.0)));
		
		float spawnRating = spawnNoise1 * spawnNoise3 * altitudeMask; // * spawnNoise * spawnNoise * altitudeMask * altitudeMask;

		if(spawnRating > (float)id.x / 1024.0 / 8.0) {
			groundBitData.worldPos = float3(spawnPos, 0);
			groundBitData.age -= 1;
		}		
	}
	else {
		groundBitData.worldPos = float3(nextPos * _MapSize, 0);		
	}

	//float2 forwardDir = normalize(vel);
	
	groundBitsCBuffer[id.x] = groundBitData;
	
}

[numthreads(1,1,1)]
void CSGenerateMeshData (uint3 id : SV_DispatchThreadID)
{
	int index = id.x * resolutionZ + id.z;

	float xRange = _QuadBounds.y - _QuadBounds.x;
	float zRange = _QuadBounds.w - _QuadBounds.z;
	float xPart = (float)id.x / (float)(resolutionX - 1);
	float zPart = (float)id.z / (float)(resolutionZ - 1);
	float x = xPart * xRange + _QuadBounds.x;
	float z = zPart * zRange + _QuadBounds.z;  // worldCoords

	//float2 globalRange = float2(xRange, zRange);
	float2 uv = float2(xPart,zPart);
	
	float4 textureSample =  heightTexture.SampleLevel(_LinearClamp, uv, 0);

	float heightRange = _HeightRange.y - _HeightRange.x;
	float height = (1.0 - textureSample.x) * heightRange + _HeightRange.x;
	
	terrainVertexCBuffer[index] = float3(x, z, height);
	terrainUVCBuffer[index] = uv;
	terrainNormalCBuffer[index] = float3(0,0,1);

	//COLOR:	
	terrainColorCBuffer[index] = float4(1, 1, 1, 1);	
}

[numthreads(1,1,1)]
void CSGenerateTriangleIndices (uint3 id : SV_DispatchThreadID)
{
	TriangleIndexData triangleIndexData0;
	TriangleIndexData triangleIndexData1;

	int index0 = (id.x * (resolutionZ - 1) + id.z) * 2;
	int index1 = index0 + 1;

	int v00 = id.x * resolutionZ + id.z;
	int v10 = (id.x + 1) * resolutionZ + id.z;
	int v01 = id.x * resolutionZ + (id.z + 1);
	int v11 = (id.x + 1) * resolutionZ + (id.z + 1);

	triangleIndexData0.v1 = v00;
	triangleIndexData0.v2 = v01;
	triangleIndexData0.v3 = v11;

	triangleIndexData1.v1 = v00;
	triangleIndexData1.v2 = v11;
	triangleIndexData1.v3 = v10;

	terrainTriangleCBuffer[index0] = triangleIndexData0;
	terrainTriangleCBuffer[index1] = triangleIndexData1;
}

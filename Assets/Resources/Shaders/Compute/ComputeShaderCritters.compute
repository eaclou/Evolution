#pragma kernel CSSimulateSkinCritterStrokes

#include "Assets/Resources/Shaders/Inc/CritterBodyAnimation.cginc"
#include "Assets/Resources/Shaders/Inc/NoiseShared.cginc"

StructuredBuffer<CritterInitData> critterInitDataCBuffer;
StructuredBuffer<CritterSimData> critterSimDataCBuffer;

RWStructuredBuffer<CritterSkinStrokeData> critterSkinStrokesWriteCBuffer;

Texture2D<float4> terrainHeightTex;
//RWStructuredBuffer<FrameBufferStrokeData> terrainFrameBufferStrokesCBuffer;

Texture2D<float4> velocityRead;

SamplerState _LinearClamp;
SamplerState _LinearRepeat;

uniform float _MapSize;

float rand(float2 co){   // OUTPUT is in [0,1] RANGE!!!
	return frac(sin(dot(co.xy ,float2(12.9898,78.233))) * 43758.5453);
}


[numthreads(16,1,1)]
void CSSimulateSkinCritterStrokes (uint3 id : SV_DispatchThreadID)
{
	
	
	
	// If detached, actual worldPos can lag behind pinned default position on agent:
	
	CritterSkinStrokeData skinStrokeData = critterSkinStrokesWriteCBuffer[id.x];
	
	int agentIndex = skinStrokeData.parentIndex;	
	CritterInitData critterInitData = critterInitDataCBuffer[agentIndex];
	CritterSimData critterSimData = critterSimDataCBuffer[agentIndex];

	float3 critterWorldPos = critterSimData.worldPos;
	float3 critterCurScale = critterInitData.boundingBoxSize * lerp(critterInitData.spawnSizePercentage, 1, critterSimData.growthPercentage);
		
	float3 spriteLocalPos = skinStrokeData.localPos * critterCurScale;
				
	float3 spriteWorldOffset = spriteLocalPos; // **** Vector from critter origin to sprite origin		
	// SWIM ANIMS:
	spriteWorldOffset = GetAnimatedPos(spriteWorldOffset, float3(0,0,0), critterInitData, critterSimData, skinStrokeData);		
			
	float3 newWorldPos = critterWorldPos + spriteWorldOffset;
	float3 curWorldPos = skinStrokeData.worldPos;

	// FLUID FLOW:
	float2 uv = curWorldPos.xy / _MapSize;
	float2 fluidVel = velocityRead.SampleLevel(_LinearRepeat, uv, 2).xy;
	float speedMult = 0.035 * _MapSize;
	curWorldPos.xy = curWorldPos.xy + fluidVel * speedMult;
	// NOISE:
	float3 noiseVel = Value3D(curWorldPos * 0.05, 17.75).yzw;
	

	float pinnedAmount = saturate((1.0 - critterSimData.decayPercentage * 12));
	pinnedAmount = 1;
	
	//curWorldPos.xyz += skinStrokeData.localPos * 0.05 * critterCurScale.x;
	//curWorldPos.z += 0.01;
	float3 worldPosition = lerp(curWorldPos, newWorldPos, pinnedAmount);
	//worldPosition.xy += noiseVel * 0.3 * critterCurScale.x;
	//worldPosition.xyz += skinStrokeData.localPos * 0.1;
			
	skinStrokeData.worldPos = worldPosition;
	critterSkinStrokesWriteCBuffer[id.x] = skinStrokeData;
	//-------------------------------------------------------------------------------------------------------------------------------



	//===================================:::::OLD:::::==================================================================================
	//float3 curAgentSize;
	//curAgentSize.xy = critterInitData.boundingBoxSize * lerp(critterInitData.spawnSizePercentage, 1, critterSimData.growthPercentage);
	//curAgentSize.z = curAgentSize.x;
	//float3 centerPosition = brushData.localPos;

	//centerPosition.xy = foodBloatAnimPos(centerPosition.xy, brushData.localPos.y, critterSimData.foodAmount);	
	//centerPosition.xy = biteAnimPos(centerPosition.xy, brushData.localPos.y, critterSimData.biteAnimCycle);	
	//centerPosition = centerPosition * curAgentSize * 0.5;

	//float bodyAspectRatio = critterInitData.boundingBoxSize.y / critterInitData.boundingBoxSize.x;
	//float bendStrength = 0.5; // * saturate(bodyAspectRatio * 0.5 - 0.4);
	//centerPosition.xy = swimAnimPos(centerPosition.xy, brushData.localPos.y, critterSimData.moveAnimCycle, critterSimData.accel, critterSimData.smoothedThrottle, bendStrength, critterSimData.turnAmount);
	
	//centerPosition.xy = rotatePointVector(centerPosition.xy, float2(0,0), critterSimData.heading);


	
	
}

/*   OLD:::::
[numthreads(16,1,1)]
void CSSimulateCritterStrokes (uint3 id : SV_DispatchThreadID)
{
	// If detached, actual worldPos can lag behind pinned default position on agent:

	CritterBodyStrokeData brushData = critterSkinStrokesWriteCBuffer[id.x];
	
	int agentIndex = brushData.parentIndex;	
	CritterInitData critterInitData = critterInitDataCBuffer[agentIndex];
	CritterSimData critterSimData = critterSimDataCBuffer[agentIndex];
		
	
	// Find new targetPosition
	float2 critterPosition = critterSimData.worldPos.xy;
					
	float2 curAgentSize = critterInitData.boundingBoxSize * lerp(critterInitData.spawnSizePercentage, 1, critterSimData.growthPercentage);

	// spriteCenterPos!!! ::::  ===========================================================================
	float2 centerPosition = brushData.localPos;
	
	centerPosition = foodBloatAnimPos(centerPosition, brushData.localPos.y, critterSimData.foodAmount);
	
	centerPosition = biteAnimPos(centerPosition, brushData.localPos.y, critterSimData.biteAnimCycle);
	
	centerPosition = centerPosition * curAgentSize * 0.5;
	
	float bodyAspectRatio = critterInitData.boundingBoxSize.y / critterInitData.boundingBoxSize.x;
	float bendStrength = 0.5; // * saturate(bodyAspectRatio * 0.5 - 0.4);
	centerPosition = swimAnimPos(centerPosition, brushData.localPos.y, critterSimData.moveAnimCycle, critterSimData.accel, critterSimData.smoothedThrottle, bendStrength, critterSimData.turnAmount);
	
	centerPosition = rotatePointVector(centerPosition, float2(0,0), critterSimData.heading);

	float3 curWorldPos = brushData.worldPos;
	float3 newWorldPos = centerPosition + float3(critterSimData.worldPos, 0);

	float2 uv = curWorldPos.xy / _MapSize;
	float2 fluidVel = velocityRead.SampleLevel(_LinearRepeat, uv, 0).xy;
	float speedMult = 0.033 * _MapSize;

	curWorldPos.xy = curWorldPos.xy + fluidVel * speedMult;

	float attachThreshold = rand(brushData.localPos.xy * 100); //critterSimData.health
	float pinnedAmount = saturate(100.0 * (critterSimData.health - attachThreshold)) * (1.0 - critterSimData.decayPercentage);   //brushData.strength;
	pinnedAmount *= 0.025;
	
	//critterSkinStrokesWriteCBuffer[id.x].strength  = critterSkinStrokesWriteCBuffer[id.x].strength + 0.006;

	if(pinnedAmount < 0.01) {
		
		critterSkinStrokesWriteCBuffer[id.x].lifeStatus = 0;
		critterSkinStrokesWriteCBuffer[id.x].strength = saturate(critterSkinStrokesWriteCBuffer[id.x].strength);
	}
	else {
		if(critterSkinStrokesWriteCBuffer[id.x].lifeStatus < 0.5) {
			critterSkinStrokesWriteCBuffer[id.x].strength = 0;
			critterSkinStrokesWriteCBuffer[id.x].lifeStatus = 1;
		}
		critterSkinStrokesWriteCBuffer[id.x].strength = min(0.5, critterSkinStrokesWriteCBuffer[id.x].strength);
		pinnedAmount = 1.0;
	}

	brushData.worldPos = lerp(curWorldPos, newWorldPos, pinnedAmount);

	critterSkinStrokesWriteCBuffer[id.x] = brushData;
}
*/
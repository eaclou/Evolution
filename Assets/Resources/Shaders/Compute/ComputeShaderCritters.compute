#pragma kernel CSSimulateSkinCritterStrokes
#pragma kernel CSUpdateCritterGenericStrokes
#pragma kernel CSSimulateCritterGenericStrokes

#include "Assets/Resources/Shaders/Inc/CritterBodyAnimation.cginc"
#include "Assets/Resources/Shaders/Inc/NoiseShared.cginc"

StructuredBuffer<CritterInitData> critterInitDataCBuffer;
StructuredBuffer<CritterSimData> critterSimDataCBuffer;
RWStructuredBuffer<CritterSkinStrokeData> critterSkinStrokesWriteCBuffer;

StructuredBuffer<CritterGenericStrokeData> critterGenericStrokesUpdateCBuffer;
RWStructuredBuffer<CritterGenericStrokeData> critterGenericStrokesWriteCBuffer;

Texture2D<float4> terrainHeightTex;

Texture2D<float4> velocityRead;

uniform float _MapSize;

uniform int _UpdateBufferStartIndex;

SamplerState _LinearClamp;
SamplerState _LinearRepeat;

float rand(float2 co){   // OUTPUT is in [0,1] RANGE!!!
	return frac(sin(dot(co.xy ,float2(12.9898,78.233))) * 43758.5453);
}


[numthreads(16,1,1)]
void CSSimulateSkinCritterStrokes (uint3 id : SV_DispatchThreadID)
{
		
	// If detached, actual worldPos can lag behind pinned default position on agent:
	
	CritterSkinStrokeData skinStrokeData = critterSkinStrokesWriteCBuffer[id.x];
	
	int agentIndex = skinStrokeData.parentIndex;	
	CritterInitData critterInitData = critterInitDataCBuffer[agentIndex];
	CritterSimData critterSimData = critterSimDataCBuffer[agentIndex];

	float3 critterWorldPos = critterSimData.worldPos;
	float3 critterCurScale = critterInitData.boundingBoxSize * lerp(critterInitData.spawnSizePercentage, 1, critterSimData.growthPercentage) * 0.5;
		
	float3 spriteLocalPos = skinStrokeData.localPos * critterCurScale;
				
	float3 spriteWorldOffset = spriteLocalPos; // **** Vector from critter origin to sprite origin		
	// SWIM ANIMS:
	spriteWorldOffset = GetAnimatedPos(spriteWorldOffset, float3(0,0,0), critterInitData, critterSimData, skinStrokeData.localPos);		
			
	float3 newWorldPos = critterWorldPos + spriteWorldOffset;
	float3 curWorldPos = skinStrokeData.worldPos;

	// FLUID FLOW:
	float2 uv = curWorldPos.xy / _MapSize;
	float2 fluidVel = velocityRead.SampleLevel(_LinearRepeat, uv, 2).xy;
	float speedMult = 0.035 * _MapSize;
	curWorldPos.xy = curWorldPos.xy + fluidVel * speedMult;
	// NOISE:
	float3 noiseVel = Value3D(curWorldPos * 0.05, 17.75).yzw;	

	float pinnedAmount = saturate((1.0 - critterSimData.decayPercentage * 12));
	pinnedAmount = 1;
	
	float3 worldPosition = lerp(curWorldPos, newWorldPos, pinnedAmount);
			
	skinStrokeData.worldPos = worldPosition;
	critterSkinStrokesWriteCBuffer[id.x] = skinStrokeData;

}

// Can optimize by parallellizing this more (32 - 256 linear)
[numthreads(1,1,1)]
void CSUpdateCritterGenericStrokes (uint3 id : SV_DispatchThreadID)
{
	int masterIndex = _UpdateBufferStartIndex + id.x;
	
	CritterGenericStrokeData data;
	data = critterGenericStrokesUpdateCBuffer[id.x];

	critterGenericStrokesWriteCBuffer[masterIndex] = data;
}

[numthreads(16,1,1)]
void CSSimulateCritterGenericStrokes (uint3 id : SV_DispatchThreadID)
{
	CritterGenericStrokeData strokeData = critterGenericStrokesWriteCBuffer[id.x];
	int agentIndex = strokeData.parentIndex;

	CritterInitData critterInitData = critterInitDataCBuffer[agentIndex];
	CritterSimData critterSimData = critterSimDataCBuffer[agentIndex];

	float3 critterWorldPos = critterSimData.worldPos;
	float3 critterCurScale = float3(1,1,1) * lerp(critterInitData.spawnSizePercentage, 1, critterSimData.growthPercentage) * 0.5;
	//float3 critterCurScale = critterInitData.boundingBoxSize * lerp(critterInitData.spawnSizePercentage, 1, critterSimData.growthPercentage) * 0.5;
		
	float3 spriteLocalPos = strokeData.bindPos * critterCurScale;
				
	float3 spriteWorldOffset = spriteLocalPos; // **** Vector from critter origin to sprite origin		
	// SWIM ANIMS:
	spriteWorldOffset = GetAnimatedPos(spriteWorldOffset, float3(0,0,0), critterInitData, critterSimData, strokeData.bindPos);		
			
	float3 newWorldPos = critterWorldPos + spriteWorldOffset;
	float3 curWorldPos = strokeData.worldPos;

	// FLUID FLOW:
	float2 uv = curWorldPos.xy / _MapSize;
	float2 fluidVel = velocityRead.SampleLevel(_LinearRepeat, uv, 2).xy;
	float speedMult = 0.035 * _MapSize;
	curWorldPos.xy = curWorldPos.xy + fluidVel * speedMult;
	// NOISE:
	float3 noiseVel = Value3D(curWorldPos * 0.05, 17.75).yzw;	

	float pinnedAmount = saturate((1.0 - critterSimData.decayPercentage * 12));
	pinnedAmount = 1;
	
	float3 worldPosition = lerp(curWorldPos, newWorldPos, pinnedAmount);
			
	strokeData.worldPos = worldPosition;
	critterGenericStrokesWriteCBuffer[id.x] = strokeData;
}

/*   OLD:::::
[numthreads(16,1,1)]
void CSSimulateCritterStrokes (uint3 id : SV_DispatchThreadID)
{
	// If detached, actual worldPos can lag behind pinned default position on agent:

	CritterBodyStrokeData brushData = critterSkinStrokesWriteCBuffer[id.x];
	
	int agentIndex = brushData.parentIndex;	
	CritterInitData critterInitData = critterInitDataCBuffer[agentIndex];
	CritterSimData critterSimData = critterSimDataCBuffer[agentIndex];
		
	
	// Find new targetPosition
	float2 critterPosition = critterSimData.worldPos.xy;
					
	float2 curAgentSize = critterInitData.boundingBoxSize * lerp(critterInitData.spawnSizePercentage, 1, critterSimData.growthPercentage);

	// spriteCenterPos!!! ::::  ===========================================================================
	float2 centerPosition = brushData.localPos;
	
	centerPosition = foodBloatAnimPos(centerPosition, brushData.localPos.y, critterSimData.foodAmount);
	
	centerPosition = biteAnimPos(centerPosition, brushData.localPos.y, critterSimData.biteAnimCycle);
	
	centerPosition = centerPosition * curAgentSize * 0.5;
	
	float bodyAspectRatio = critterInitData.boundingBoxSize.y / critterInitData.boundingBoxSize.x;
	float bendStrength = 0.5; // * saturate(bodyAspectRatio * 0.5 - 0.4);
	centerPosition = swimAnimPos(centerPosition, brushData.localPos.y, critterSimData.moveAnimCycle, critterSimData.accel, critterSimData.smoothedThrottle, bendStrength, critterSimData.turnAmount);
	
	centerPosition = rotatePointVector(centerPosition, float2(0,0), critterSimData.heading);

	float3 curWorldPos = brushData.worldPos;
	float3 newWorldPos = centerPosition + float3(critterSimData.worldPos, 0);

	float2 uv = curWorldPos.xy / _MapSize;
	float2 fluidVel = velocityRead.SampleLevel(_LinearRepeat, uv, 0).xy;
	float speedMult = 0.033 * _MapSize;

	curWorldPos.xy = curWorldPos.xy + fluidVel * speedMult;

	float attachThreshold = rand(brushData.localPos.xy * 100); //critterSimData.health
	float pinnedAmount = saturate(100.0 * (critterSimData.health - attachThreshold)) * (1.0 - critterSimData.decayPercentage);   //brushData.strength;
	pinnedAmount *= 0.025;
	
	//critterSkinStrokesWriteCBuffer[id.x].strength  = critterSkinStrokesWriteCBuffer[id.x].strength + 0.006;

	if(pinnedAmount < 0.01) {
		
		critterSkinStrokesWriteCBuffer[id.x].lifeStatus = 0;
		critterSkinStrokesWriteCBuffer[id.x].strength = saturate(critterSkinStrokesWriteCBuffer[id.x].strength);
	}
	else {
		if(critterSkinStrokesWriteCBuffer[id.x].lifeStatus < 0.5) {
			critterSkinStrokesWriteCBuffer[id.x].strength = 0;
			critterSkinStrokesWriteCBuffer[id.x].lifeStatus = 1;
		}
		critterSkinStrokesWriteCBuffer[id.x].strength = min(0.5, critterSkinStrokesWriteCBuffer[id.x].strength);
		pinnedAmount = 1.0;
	}

	brushData.worldPos = lerp(curWorldPos, newWorldPos, pinnedAmount);

	critterSkinStrokesWriteCBuffer[id.x] = brushData;
}
*/
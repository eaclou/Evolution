#pragma kernel CSGetAlgaeGridSamples
#pragma kernel CSUpdateAlgaeGrid
#pragma kernel CSInitializeAlgaeGrid
#pragma kernel CSRemoveAlgaeAtLocations
#pragma kernel CSMeasureTotalAlgae
#pragma kernel CSAddAlgaeAtCoords


#include "Assets/Resources/Shaders/Inc/StructsCritterData.cginc"

StructuredBuffer<CritterInitData> critterInitDataCBuffer;
StructuredBuffer<CritterSimData> critterSimDataCBuffer;

Texture2D<float4> ObstaclesRead;

RWStructuredBuffer<float4> algaeGridSamplesCBuffer;
StructuredBuffer<float4> algaeGridEatAmountsCBuffer;

Texture2D<float4> algaeGridRead;
RWTexture2D<float4> algaeGridWrite;

RWStructuredBuffer<float4> outputValuesCBuffer;
StructuredBuffer<float4> addAlgaeCBuffer;
Texture2D<float4> measureValuesTex;
RWTexture2D<float4> pooledResultTex;

SamplerState _LinearClamp;
SamplerState _LinearRepeat;
SamplerState _PointClamp;
SamplerState _PointRepeat;

uniform float _AlgaeGridDiffusion;
uniform float _MapSize;

[numthreads(1,1,1)]
void CSGetAlgaeGridSamples (uint3 id : SV_DispatchThreadID)
{	
	CritterSimData critterSimData = critterSimDataCBuffer[id.x];

	float2 uv = critterSimData.worldPos.xy / _MapSize;
	float4 algaeGridAmount = algaeGridRead.SampleLevel(_PointClamp, uv, 0);

	// want gradient! -- pack into .yz channels :::
	// calculate gradient each step and store value

	algaeGridSamplesCBuffer[id.x] = algaeGridAmount;
}

[numthreads(32,32,1)]
void CSUpdateAlgaeGrid (uint3 id : SV_DispatchThreadID)
{	
	// Diffusion - food blurs and spreads out
	// Store Gradient of increasing food density
			
    float amountRight = algaeGridRead[int2(id.x + 1, id.y)].x;
    float amountLeft = algaeGridRead[int2(id.x - 1, id.y)].x;
    float amountUp = algaeGridRead[int2(id.x, id.y + 1)].x;
    float amountDown = algaeGridRead[int2(id.x, id.y - 1)].x;
    float amountCenter = algaeGridRead[id.xy].x;

	// Check vs obstacles??
	float xCoord = ((float)id.x + 0.5)  / 32;  // ** Bad hardcoded!!!!!
	float yCoord = ((float)id.y + 0.5)  / 32;
	float2 uvOrigin = float2(xCoord, yCoord);
	float ps = 1.0 / 32;
	
	half4 centerObstacle = ObstaclesRead.SampleLevel(_LinearClamp, uvOrigin, 0);

	half4 leftObstacle = ObstaclesRead.SampleLevel(_LinearClamp, uvOrigin + half2(-ps, 0), 0);
	half4 rightObstacle = ObstaclesRead.SampleLevel(_LinearClamp, uvOrigin + half2(ps, 0), 0);
	half4 topObstacle = ObstaclesRead.SampleLevel(_LinearClamp, uvOrigin + half2(0, ps), 0);
	half4 bottomObstacle = ObstaclesRead.SampleLevel(_LinearClamp, uvOrigin + half2(0, -ps), 0);	
		
	if(centerObstacle.b > 0.5) amountCenter = 0.0;
	if(leftObstacle.b > 0.5) amountLeft = amountCenter;
	if(rightObstacle.b > 0.5) amountRight = amountCenter;
	if(topObstacle.b > 0.5) amountUp = amountCenter;
	if(bottomObstacle.b > 0.5) amountDown = amountCenter;
		

    float deltaX = amountRight - amountLeft;
    float deltaY = amountUp - amountDown;

	float2 grad = float2(0,0);
	if(abs(deltaX) > 0.000001 || abs(deltaY) > 0.000001) {
		grad = normalize(float2(deltaX, deltaY));
	}
    
	//float2 grad = normalize(float2(deltaX, deltaY));
	// Make sure this doesn't return null/undefined!!!!! ******  ***  (I didn't) ****
	
	float newAmount = lerp(amountCenter, (amountCenter + amountRight + amountLeft + amountUp + amountDown) / 5, _AlgaeGridDiffusion);

	algaeGridWrite[id.xy] = float4(newAmount, grad, 1.0);
}

[numthreads(32,32,1)]
void CSInitializeAlgaeGrid (uint3 id : SV_DispatchThreadID)
{	
	algaeGridWrite[id.xy] = float4(0.033, 0, 0, 1);
}

[numthreads(1,1,1)]
void CSRemoveAlgaeAtLocations (uint3 id : SV_DispatchThreadID)
{	
	// takes a list of info:
	// --cell index x,y
	// --amount of food to remove / mouth stats
	// buffer of floats per Critter?

	uint xIndex = floor(critterSimDataCBuffer[id.x].worldPos.x / _MapSize * 32);  // 32 = hardcoded resolution ****
	uint yIndex = floor(critterSimDataCBuffer[id.x].worldPos.y / _MapSize * 32);

	uint2 cellIndex = uint2(xIndex, yIndex);

	float4 currentAmount = algaeGridRead[cellIndex];
	float amountToRemove = algaeGridEatAmountsCBuffer[id.x].x;

	currentAmount.x = max(0.0, currentAmount.x - amountToRemove);

	algaeGridWrite[cellIndex] = currentAmount;

	// WHY SO SLOW????
}

[numthreads(1,1,1)]
void CSMeasureTotalAlgae (uint3 id : SV_DispatchThreadID)
{	
	// for each output pixel, loop through original 2x2 pixels and sum them together

	float totalAlgae = 0.0;

	for(int x = 0; x < 2; x++) {
		for(int y = 0; y < 2; y++) {
			int xIndex = id.x * 2 + x;
			int yIndex = id.y * 2 + y;

			totalAlgae += measureValuesTex[int2(xIndex, yIndex)].x;
		}
	}

	float4 pixValue = float4(totalAlgae,9,1,1); // *** ?????

	pooledResultTex[id.xy] = pixValue;

	outputValuesCBuffer[0] = pixValue;
}

[numthreads(1,1,1)]
void CSAddAlgaeAtCoords (uint3 id : SV_DispatchThreadID)
{	
	float4 data = addAlgaeCBuffer[id.x];
	
	float amount = data.x;
	int xIndex = floor(data.y * 32.0);
	int yIndex = floor(data.z * 32.0);
	int2 index = int2(xIndex, yIndex);

	float4 currentAlgaeGrid = algaeGridRead[index];

	currentAlgaeGrid.x += amount;

	algaeGridWrite[index] = currentAlgaeGrid;
}
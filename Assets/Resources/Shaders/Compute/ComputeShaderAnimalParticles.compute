#pragma kernel CSMeasureInitCritterDistances
#pragma kernel CSReduceCritterDistances32
#pragma kernel CSEatSelectedAnimalParticles
#pragma kernel CSCopyAnimalParticlesBuffer
#pragma kernel CSMeasureTotalAnimalParticlesAmount
#pragma kernel CSSimulateAnimalParticles

#include "Assets/Resources/Shaders/Inc/StructsCritterData.cginc"
#include "Assets/Resources/Shaders/Inc/StructsAnimalParticles.cginc"

StructuredBuffer<CritterInitData> critterInitDataCBuffer;
StructuredBuffer<CritterSimData> critterSimDataCBuffer;

StructuredBuffer<AnimalParticleData> animalParticlesRead;
RWStructuredBuffer<AnimalParticleData> animalParticlesWrite;
RWTexture2D<float4> animalParticlesNearestCrittersRT;

RWStructuredBuffer<AnimalParticleData> closestParticlesDataCBuffer;

StructuredBuffer<float> animalParticlesEatAmountsRead;
RWStructuredBuffer<float> animalParticlesEatAmountsCBuffer;

StructuredBuffer<int> selectRespawnAnimalParticleIndicesCBuffer;

Texture2D<float4> critterDistancesRead; // used to reduce animalParticlesNearestCrittersRT down to minimum distancesanimalParticleData
RWTexture2D<float4> critterDistancesWrite;

Texture2D<float4> obstaclesRead;  // water info
Texture2D<float4> velocityRead;
Texture2D<float4> altitudeRead;

Texture2D<float4> _SpawnDensityMap;

uniform float _RespawnAnimalParticles;
uniform float _Time;
uniform float _MapSize;

uniform float _MinParticleSize;
uniform float _MaxParticleSize;
uniform float _ParticleNutrientDensity; // refactor how nutrient content works

uniform float _AnimalParticleRegrowthRate;

uniform float _SpawnPosX;
uniform float _SpawnPosY;

uniform float _GlobalOxygenLevel;
uniform float _GlobalAlgaeLevel;

uniform float _MasterSwimSpeed; // = 0.35;
uniform float _AlignMaskRange; // = 0.025;
uniform float _AlignMaskOffset; // = 0.0833;
uniform float _AlignSpeedMult; // = 0.00015;
uniform float _AttractMag; // = 0.0000137;
uniform float _AttractMaskMaxDistance; // = 0.0036;
uniform float _AttractMaskOffset; // = 0.5;
uniform float _SwimNoiseMag; // = 0.000086;
uniform float _SwimNoiseFreqMin; // = 0.00002
uniform float _SwimNoiseFreqRange; // = 0.0002
uniform float _SwimNoiseOnOffFreq; //  = 0.0001
uniform float _ShoreCollisionMag; // = 0.0065;
uniform float _ShoreCollisionDistOffset; // = 0.15;
uniform float _ShoreCollisionDistSlope; // = 3.5;

SamplerState _LinearClamp;
SamplerState _LinearRepeat;
SamplerState _PointClamp;
SamplerState _PointRepeat;

float rand(float2 co){   // OUTPUT is in [0,1] RANGE!!!
	return frac(sin(dot(co.xy ,float2(12.9898,78.233))) * 43758.5453);
}

[numthreads(1024,1,1)]
void CSMeasureInitCritterDistances (uint3 id : SV_DispatchThreadID)
{	
	int particleIndex = id.x;
	int critterIndex = id.y;

	AnimalParticleData particleData = animalParticlesRead[particleIndex];
	CritterInitData critterInitData = critterInitDataCBuffer[critterIndex];
	CritterSimData critterSimData = critterSimDataCBuffer[critterIndex];

	float mouthRadius = critterInitData.boundingBoxSize.x * critterSimData.growthPercentage; // **** REMEMBER TO *0.5 EVENTUALLY FOR ACCURATE SIZE
	float2 mouthCenterPos = critterSimData.heading * critterInitData.boundingBoxSize.y * 0.5 * critterSimData.growthPercentage;

	float2 particleToCritter = critterSimData.worldPos.xy + mouthCenterPos * 1.0 - particleData.worldPos.xy;

	float distanceSquared = particleToCritter.x * particleToCritter.x + particleToCritter.y * particleToCritter.y;
	
	animalParticlesNearestCrittersRT[int2(particleIndex, critterIndex)] = float4(particleData.index, distanceSquared, particleData.worldPos.xy);
		
}

[numthreads(1,1,1)]
void CSReduceCritterDistances32 (uint3 id : SV_DispatchThreadID)
{	
	
	int critterIndex = id.y;

	CritterSimData critterSimData = critterSimDataCBuffer[critterIndex];
			
	float closestParticleIndex = 0;
	float minSquaredDistance = 50000;
		
	for(int i = 0; i < 32; i++) {
		
		int particleIndex = id.x * 32 + i;
		
		float4 sourceData = critterDistancesRead[int2(particleIndex, critterIndex)];
		
		AnimalParticleData particleData = animalParticlesRead[particleIndex];

		if(sourceData.y < minSquaredDistance) {
			if(particleData.active > 0.5) {
				minSquaredDistance = sourceData.y;
				closestParticleIndex = sourceData.x;
			}				
		}
	}
		
	AnimalParticleData closestAnimalData = animalParticlesRead[closestParticleIndex];	
		
	critterDistancesWrite[int2(id.x, critterIndex)] = float4(closestParticleIndex, minSquaredDistance, 1.0, 1.0);
	closestParticlesDataCBuffer[critterIndex] = closestAnimalData; // assuming there's only 1 thread at end
}


[numthreads(1,1,1)]
void CSEatSelectedAnimalParticles (uint3 id : SV_DispatchThreadID)
{	
	// Check distance to nearest particle
	int critterIndex = id.x;

	float4 data = critterDistancesRead[int2(0, id.x)];

	int particleIndex = (int)data.x;

	AnimalParticleData particleData = animalParticlesRead[particleIndex];
	//particleData.closestCritterDistance = data.y;
	animalParticlesWrite[particleIndex] = particleData;

	CritterInitData critterInitData = critterInitDataCBuffer[critterIndex];
	CritterSimData critterSimData = critterSimDataCBuffer[critterIndex];

	float eatenAmount = 0.0;

	float isAlive01 = saturate((critterSimData.embryoPercentage - 0.99) * 10000) * saturate(((1.0 - critterSimData.decayPercentage) - 0.99) * 10000);

	float distanceSquared = data.y;
	float mouthRadius = critterInitData.boundingBoxSize.x * critterSimData.growthPercentage;  // **** REMEMBER TO *0.5 EVENTUALLY FOR ACCURATE SIZE
	float particleRadius = particleData.radius;
	float combinedRadius = (mouthRadius + particleRadius * 0.5) * isAlive01 * critterSimData.consumeOn;
		

	if(distanceSquared < combinedRadius * combinedRadius) {	
		
		if(critterSimData.consumeOn > 0.5) {   // revisit
			eatenAmount = particleData.biomass; //mouthRadius * mouthRadius * critterInitData.eatEfficiencyMeat * 0.167f; //particleData.nutrientContent;
			animalParticlesWrite[particleIndex].active = 0;
			animalParticlesWrite[particleIndex].isSwallowed = 1.0;
			animalParticlesWrite[particleIndex].critterIndex = critterIndex;		
			animalParticlesWrite[particleIndex].biomass = 0.0; // ?????   *****

			//animalParticlesWrite[particleIndex].nutrientContent = particleData.nutrientContent - eatenAmount;
			//animalParticlesWrite[particleIndex].closestCritterDistance = 1.0;
				
			//if(animalParticlesWrite[particleIndex].nutrientContent <= 0) {
				//animalParticlesWrite[particleIndex].active = 0;
				//animalParticlesWrite[particleIndex].isSwallowed = 1.0;
				//animalParticlesWrite[particleIndex].critterIndex = critterIndex;				
			//}
		}	
	}

	animalParticlesEatAmountsCBuffer[id.x] = eatenAmount;
}

[numthreads(1024,1,1)]
void CSCopyAnimalParticlesBuffer (uint3 id : SV_DispatchThreadID)
{	
	AnimalParticleData particleData = animalParticlesRead[id.x];
	
	animalParticlesWrite[id.x] = particleData;
}

[numthreads(1,1,1)]
void CSMeasureTotalAnimalParticlesAmount (uint3 id : SV_DispatchThreadID)
{	
	AnimalParticleData copyData = animalParticlesRead[id.x];

	// Update this function to measure all required resource values, for example:
	// Total Oxygen used, total waste released, Total Algae Eaten, etc.?
	
	float totalBiomassAmount = 0.0;
	float totalOxygenUsed = 0.0;
	float totalWasteProduced = 0.0;
	float totalAlgaeConsumed = 0.0;
	
	for(int i = 0; i < 32; i++) {		
		int particleIndex = id.x * 32 + i;		
		AnimalParticleData particleData = animalParticlesRead[particleIndex];				
		totalBiomassAmount += particleData.biomass * particleData.active;
		totalOxygenUsed += particleData.oxygenUsed;
		totalWasteProduced += particleData.wasteProduced;
		totalAlgaeConsumed += particleData.algaeConsumed;
	}

	copyData.biomass = totalBiomassAmount;
	copyData.oxygenUsed = totalOxygenUsed;
	copyData.wasteProduced = totalWasteProduced;
	copyData.algaeConsumed = totalAlgaeConsumed;
		
	animalParticlesWrite[id.x] = copyData;
}

[numthreads(1024,1,1)]
void CSSimulateAnimalParticles (uint3 id : SV_DispatchThreadID)
{
	// Check if particle isn't in the water:

	AnimalParticleData animalParticle = animalParticlesRead[id.x];
		
	float2 uv = animalParticle.worldPos.xy / _MapSize;
	

	if(animalParticle.active > 0.5) { // poor man's boolean
	// *** Update this to sample altitude instead.  ** to avoid unreachable food
		float2 altUV = uv * 0.5 + 0.25;

		// ** Pre-compute this in future:::: *****
		float4 terrainSampleCenter = altitudeRead.SampleLevel(_LinearClamp, altUV, 1);
		float4 terrainSampleRight = altitudeRead.SampleLevel(_LinearClamp, altUV + float2(0.001, 0), 1);
		float4 terrainSampleTop = altitudeRead.SampleLevel(_LinearClamp, altUV + float2(0, 0.001), 1);

		float altitude = terrainSampleCenter.x;			
		
		CritterSimData critterSimData = critterSimDataCBuffer[id.x % 32];					

		float2 fluidVel = velocityRead.SampleLevel(_LinearRepeat, uv, 2).xy;  // water velocity
		float fluidSpeedMult = 0.0045;				
		float2 nextPos = uv + fluidVel * fluidSpeedMult;  // carried by water

		for(int i = 0; i < 4; i++) {
			int neighborIndex = (id.x + round(_Time * 33) + i * 256) % 1024;
			
			AnimalParticleData neighborParticle = animalParticlesRead[neighborIndex];
			float2 neighborPos = neighborParticle.worldPos.xy;
			float2 dirToNeighbor = neighborPos - animalParticle.worldPos.xy;
			float distToNeighborSquared = dirToNeighbor.x * dirToNeighbor.x + dirToNeighbor.y * dirToNeighbor.y;		
			
			float distanceMask = 1.0 - saturate(distToNeighborSquared * _AlignMaskRange - _AlignMaskOffset);

			float2 targetFacingDir = lerp(animalParticle.velocity, neighborParticle.velocity, 0.1 * distanceMask);
			float facingDirSqrMag = targetFacingDir.x * targetFacingDir.x + targetFacingDir.y * targetFacingDir.y;
						
			if(facingDirSqrMag > 0.0) {
				targetFacingDir = normalize(targetFacingDir);
			}
			else {				
				//speed *= 0.033; // needed?
			}

			// Match orientation with nearest neighbor
			nextPos += targetFacingDir * _AlignSpeedMult * _MasterSwimSpeed;
		
			// move towards/away from nearest neighbor:			
			float attractDistanceMask = 1.0 - saturate(distToNeighborSquared * _AttractMaskMaxDistance - _AttractMaskOffset);
			float2 attractVel = float2(saturate(dirToNeighbor.x), saturate(dirToNeighbor.y)) * attractDistanceMask;
			nextPos += attractVel * _AttractMag * _MasterSwimSpeed;
		}
		
		//random noisy movement:		
		float noiseFreq = (_SwimNoiseFreqMin + _SwimNoiseFreqRange * ((float)id.x / 1024));
		float noiseOnOff = saturate(rand(float2(id.x, _Time * _SwimNoiseOnOffFreq)));
		float2 noiseVel = float2(rand(float2(id.x, _Time * noiseFreq)), rand(float2(_Time * noiseFreq * 1.347, id.x % 32))) * 2.0 - 1.0;  // get into -1 to 1 range		
		nextPos += noiseVel * _SwimNoiseMag * _MasterSwimSpeed * noiseOnOff;

		// Shoreline "Collision"		
		float2 slope = float2(terrainSampleRight.x - terrainSampleCenter.x, terrainSampleTop.x - terrainSampleCenter.x);
		float aboveWaterMask = saturate((altitude - _ShoreCollisionDistOffset) * _ShoreCollisionDistSlope);		
		float2 landCollisionVel = -slope * aboveWaterMask * _ShoreCollisionMag;
		nextPos += landCollisionVel * _MasterSwimSpeed;		
		
		float2 defaultNextPos = nextPos * _MapSize;
			
		animalParticlesWrite[id.x].velocity = defaultNextPos - animalParticle.worldPos.xy;
		animalParticlesWrite[id.x].age = animalParticle.age + 0.0003;
		animalParticlesWrite[id.x].worldPos.xy = defaultNextPos;
		
		// SPLINE::::::
		float restDistance = 0.2;
		float lerpStrength = 0.88;

		float2 p0 = animalParticlesWrite[id.x].worldPos.xy;
	
		float2 p1 = animalParticle.p1;
		float2 vec0to1 = p1 - p0; // after p0 has been moved, vector from old P1 to new P0	
		p1 = lerp(p1, p0 + normalize(vec0to1) * restDistance, lerpStrength * 1);

		float2 p2 = animalParticle.p2;
		float2 vec1to2 = p2 - p1;
		p2 = lerp(p2, p1 + normalize(vec1to2) * restDistance, lerpStrength * 1);

		float2 p3 = animalParticle.p3;
		float2 vec2to3 = p3 - p2;
		p3 = lerp(p3, p2 + normalize(vec2to3) * restDistance, lerpStrength * 1);
				
		animalParticlesWrite[id.x].p1 = p1;
		animalParticlesWrite[id.x].p2 = p2;
		animalParticlesWrite[id.x].p3 = p3;

		// Resource Conversions:::::
		animalParticlesWrite[id.x].oxygenUsed = 0.1 * _GlobalOxygenLevel * animalParticle.biomass;
		animalParticlesWrite[id.x].wasteProduced = 0.1345 * animalParticle.biomass;
		animalParticlesWrite[id.x].algaeConsumed = 0.001 * _GlobalAlgaeLevel * animalParticle.biomass;
		
		if(animalParticle.digestedAmount > 1.0) {  // Fully Decayed
			animalParticlesWrite[id.x].active = 0.0;
			animalParticlesWrite[id.x].refactoryAge = 1.0;
		}
	}
	else {  // INACTIVE:::
		animalParticlesWrite[id.x].refactoryAge = animalParticle.refactoryAge + _AnimalParticleRegrowthRate;
	}
	if(animalParticle.age > 2.0) {
		animalParticlesWrite[id.x].digestedAmount = animalParticle.digestedAmount + 0.001;  // being used to indicate decayRate
	}

	if(_RespawnAnimalParticles > 0.5) {		
		
		if(animalParticlesRead[id.x].refactoryAge > 1.0) {
			
			float rand01 = rand(float2(_Time * 135.79 + (float)animalParticlesRead[id.x].index * 30.17896, _Time * 28.463));
			float randX = rand(float2((float)id.x, _Time));
			float randY = rand(float2(randX * 62.39 + _Time, (float)id.x));

			float2 spawnOriginUV = float2(_SpawnPosX, _SpawnPosY);

			float2 spawnUV = spawnOriginUV + float2(randX, randY) * 0.003;			
			float4 spawnDensitySample = _SpawnDensityMap.SampleLevel(_LinearClamp, spawnUV, 0);

			//float spawnThreshold = 0.001;
			//if(rand01 < 0.5) {  // to prevent mass respawning, overshooting the intended max global food amount ?  // Needed?
				//if(spawnDensitySample.x > spawnThreshold) {
				
			float2 worldPos = float2(spawnUV.x * _MapSize, spawnUV.y * _MapSize);
			animalParticlesWrite[id.x].worldPos.xy = worldPos;
			animalParticlesWrite[id.x].p1 = worldPos - float2(0, 0.1);
			animalParticlesWrite[id.x].p2 = worldPos - float2(0, 0.2);
			animalParticlesWrite[id.x].p3 = worldPos - float2(0, 0.3);

			float randRadius = rand(float2(randX * 10, randY * -3.37)) * (_MaxParticleSize - _MinParticleSize) + _MinParticleSize;					
			animalParticlesWrite[id.x].radius = randRadius;
			animalParticlesWrite[id.x].biomass = randRadius * randRadius * 3.141592 * _ParticleNutrientDensity;
			animalParticlesWrite[id.x].active = 1.0;
			animalParticlesWrite[id.x].refactoryAge = 0.0;
			animalParticlesWrite[id.x].isSwallowed = 0.0;
			animalParticlesWrite[id.x].digestedAmount = 0.0;
			animalParticlesWrite[id.x].age = rand(float2(rand01 * 70.158, randX * 13.37));

				//}			
			//}			
		}		
	}
}

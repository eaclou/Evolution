#pragma kernel CSGetAlgaeGridSamples
#pragma kernel CSUpdateAlgaeGrid
#pragma kernel CSAdvectResourceGrid
#pragma kernel CSInitializeAlgaeGrid
#pragma kernel CSRemoveAlgaeAtLocations
#pragma kernel CSMeasureTotalAlgae
#pragma kernel CSAddResourcesAtCoords
#pragma kernel CSInitRD
#pragma kernel CSSimRD
#pragma kernel CSAdvectRD


#include "Assets/Resources/Shaders/Inc/StructsCritterData.cginc"
#include "Assets/Resources/Shaders/Inc/StructsAlgaeParticles.cginc"

StructuredBuffer<CritterInitData> critterInitDataCBuffer;
StructuredBuffer<CritterSimData> critterSimDataCBuffer;

Texture2D<float4> ObstaclesRead;

StructuredBuffer<AlgaeParticleData> algaeParticlesRead;

RWStructuredBuffer<float4> algaeGridSamplesCBuffer;
StructuredBuffer<float4> algaeGridEatAmountsCBuffer;

Texture2D<float4> VelocityRead;

Texture2D<float4> _AltitudeTex;

Texture2D<float4> _SpiritBrushTex;

Texture2D<float4> algaeGridRead;
RWTexture2D<float4> algaeGridWrite;

Texture2D<float4> rdRead;
RWTexture2D<float4> rdWrite;

RWStructuredBuffer<float4> outputValuesCBuffer;
StructuredBuffer<float4> addAlgaeCBuffer;
Texture2D<float4> measureValuesTex;
RWTexture2D<float4> pooledResultTex;

SamplerState _LinearClamp;
SamplerState _LinearRepeat;
SamplerState _PointClamp;
SamplerState _PointRepeat;

uniform float _AlgaeGridDiffusion;
uniform float _TextureResolution;
uniform float _DeltaTime;
uniform float _InvGridScale;
uniform float _MapSize;

uniform float _IsSpiritBrushOn;
uniform float _SpiritBrushPosNeg;
uniform float _SpiritBrushIntensity;

uniform float _CoordX;
uniform float _CoordY;

uniform float _Time;

[numthreads(1,1,1)]
void CSGetAlgaeGridSamples (uint3 id : SV_DispatchThreadID)
{	
	CritterSimData critterSimData = critterSimDataCBuffer[id.x];

	float2 uv = critterSimData.worldPos.xy / _MapSize;
	float4 algaeGridAmount = algaeGridRead.SampleLevel(_PointClamp, uv, 0);

	// want gradient! -- pack into .yz channels :::
	// calculate gradient each step and store value

	algaeGridSamplesCBuffer[id.x] = algaeGridAmount;
}

[numthreads(32,32,1)]
void CSUpdateAlgaeGrid (uint3 id : SV_DispatchThreadID)
{	
	// Diffusion - food blurs and spreads out
	// Store Gradient of increasing food density
			
    float4 amountRight = algaeGridRead[int2(id.x + 1, id.y)];
    float4 amountLeft = algaeGridRead[int2(id.x - 1, id.y)];
    float4 amountUp = algaeGridRead[int2(id.x, id.y + 1)];
    float4 amountDown = algaeGridRead[int2(id.x, id.y - 1)];
    float4 amountCenter = algaeGridRead[id.xy];

	// Check vs obstacles??
	float xCoord = ((float)id.x + 0.5)  / 32;  // ** Bad hardcoded!!!!!
	float yCoord = ((float)id.y + 0.5)  / 32;
	float2 uvOrigin = float2(xCoord, yCoord);
	float ps = 1.0 / 32;
	
	half4 centerObstacle = ObstaclesRead.SampleLevel(_LinearClamp, uvOrigin, 0);

	half4 leftObstacle = ObstaclesRead.SampleLevel(_LinearClamp, uvOrigin + half2(-ps, 0), 0);
	half4 rightObstacle = ObstaclesRead.SampleLevel(_LinearClamp, uvOrigin + half2(ps, 0), 0);
	half4 topObstacle = ObstaclesRead.SampleLevel(_LinearClamp, uvOrigin + half2(0, ps), 0);
	half4 bottomObstacle = ObstaclesRead.SampleLevel(_LinearClamp, uvOrigin + half2(0, -ps), 0);	
		
	if(centerObstacle.b > 0.5) amountCenter = 0.0;
	if(leftObstacle.b > 0.5) amountLeft = amountCenter;
	if(rightObstacle.b > 0.5) amountRight = amountCenter;
	if(topObstacle.b > 0.5) amountUp = amountCenter;
	if(bottomObstacle.b > 0.5) amountDown = amountCenter;
		

    //float deltaX = amountRight.x - amountLeft.x;
    //float deltaY = amountUp.x - amountDown.x;

	//float2 grad = float2(0,0);
	//if(abs(deltaX) > 0.000001 || abs(deltaY) > 0.000001) {
	//	grad = normalize(float2(deltaX, deltaY));
	//}
    
	//float2 grad = normalize(float2(deltaX, deltaY));
	// Make sure this doesn't return null/undefined!!!!! ******  ***  (I didn't) ****
	
	float4 newAmount = lerp(amountCenter, (amountCenter + amountRight + amountLeft + amountUp + amountDown) / 5, _AlgaeGridDiffusion);

	algaeGridWrite[id.xy] = newAmount; //float4(newAmount, grad, 1.0);
}

[numthreads(32,32,1)]
void CSAdvectResourceGrid (uint3 id : SV_DispatchThreadID)
{

	float xCoord = ((float)id.x + 0.5) / 32.0;
	float yCoord = ((float)id.y + 0.5) / 32.0;
	float2 uvOrigin = float2(xCoord, yCoord);

	float isSolid = ObstaclesRead.SampleLevel(_LinearClamp, uvOrigin, 0).b;	
	float2 uvSample = uvOrigin - _DeltaTime * _InvGridScale * VelocityRead.SampleLevel(_LinearRepeat, uvOrigin, 0).xy;
	float4 newDensity = algaeGridRead.SampleLevel(_LinearRepeat, uvSample, 0);
	
	AlgaeParticleData particleData = algaeParticlesRead[(id.x * 32 + id.y + round(_Time * 75.4837)) % 1024];
	float2 particleCoords = particleData.worldPos / _MapSize;
	float dist = length(uvOrigin - particleCoords);
	float distMask = saturate(1.0 - dist * 7);
	
	newDensity.y += saturate(particleData.biomass * 6) / 46 * distMask - 0.0006;

	/*if(isSolid > 0.5) {
		algaeGridWrite[id.xy] = 0; //newDensity;

		return;
	}*/
			
	algaeGridWrite[id.xy] = saturate(newDensity);
}

[numthreads(32,32,1)]
void CSInitializeAlgaeGrid (uint3 id : SV_DispatchThreadID)
{	
	algaeGridWrite[id.xy] = float4(0,0,0,0); // float4(saturate(sin((float2)id.xy / 2)) * 0.25, 0.11, 0.3);  // x= nutrients, y= algae, z= decomposers, w= detritus
}

[numthreads(1,1,1)]
void CSRemoveAlgaeAtLocations (uint3 id : SV_DispatchThreadID)
{	
	// takes a list of info:
	// --cell index x,y
	// --amount of food to remove / mouth stats
	// buffer of floats per Critter?

	uint xIndex = floor(critterSimDataCBuffer[id.x].worldPos.x / _MapSize * 32);  // 32 = hardcoded resolution ****
	uint yIndex = floor(critterSimDataCBuffer[id.x].worldPos.y / _MapSize * 32);

	uint2 cellIndex = uint2(xIndex, yIndex);

	float4 currentAmount = algaeGridRead[cellIndex];
	float amountToRemove = algaeGridEatAmountsCBuffer[id.x].x;

	currentAmount.x = max(0.0, currentAmount.x - amountToRemove);

	algaeGridWrite[cellIndex] = currentAmount;

	// WHY SO SLOW????
}

[numthreads(1,1,1)]
void CSMeasureTotalAlgae (uint3 id : SV_DispatchThreadID)
{	
	// for each output pixel, loop through original 2x2 pixels and sum them together

	float totalAlgae = 0.0;

	for(int x = 0; x < 2; x++) {
		for(int y = 0; y < 2; y++) {
			int xIndex = id.x * 2 + x;
			int yIndex = id.y * 2 + y;

			totalAlgae += measureValuesTex[int2(xIndex, yIndex)].x;
		}
	}

	float4 pixValue = float4(totalAlgae,9,1,1); // *** ?????

	pooledResultTex[id.xy] = pixValue;

	outputValuesCBuffer[0] = pixValue;
}

[numthreads(1,1,1)]
void CSAddResourcesAtCoords (uint3 id : SV_DispatchThreadID)
{	
	float4 data = addAlgaeCBuffer[id.x];
	
	int xIndex = floor(_CoordX * 32.0);  // *** hardcoded resolution!!!!
	int yIndex = floor(_CoordY * 32.0);
	int2 index = int2(xIndex, yIndex);

	float4 currentAlgaeGrid = algaeGridRead[index];

	currentAlgaeGrid += data;

	algaeGridWrite[index] = saturate(currentAlgaeGrid);
}


[numthreads(32,32,1)]
void CSInitRD (uint3 id : SV_DispatchThreadID)
{	
	rdWrite[id.xy] = float4(0, 0, 0, 1);   // Start blank
	
	/*
	float2 uv = ((float2)id.xy + 0.5) / _TextureResolution;

	float dist = 1.0 - saturate(length((uv * 1.17 % 1) - 0.5) * 33);
	float val = dist;
	rdWrite[id.xy] = float4(1 - val, val, 0, 1);
	*/
}

[numthreads(32,32,1)]
void CSSimRD (uint3 id : SV_DispatchThreadID)
{	
	float s = 1 / _TextureResolution;
	float deltaTime = 0.054;

	float2 uv = float2((float2)id.xy + 0.5) / _TextureResolution;

	// Neighbour cells
	//algaeGridRead.SampleLevel(_LinearRepeat, uvSample, 0);
	float4 bl = rdRead.SampleLevel(_PointClamp, uv + float2(-s, +s), 0);	// F[x-1, y+1]: Bottom Left
	float4 cl = rdRead.SampleLevel(_PointClamp, uv + float2(-s,  0), 0);	// F[x-1, y  ]: Centre Left
	float4 tl = rdRead.SampleLevel(_PointClamp, uv + float2(-s, -s), 0); // F[x-1, y-1]: Top Left
	float4 tc = rdRead.SampleLevel(_PointClamp, uv + float2( 0, -s), 0);	// F[x,   y-1]: Top Centre
	float4 tr = rdRead.SampleLevel(_PointClamp, uv + float2(+s, -s), 0);	// F[x,   y-1]: Top Right
	float4 cc = rdRead.SampleLevel(_PointClamp, uv + float2( 0,  0), 0);	// F[x,   y  ]: Centre Centre
	float4 br = rdRead.SampleLevel(_PointClamp, uv + float2(+s, +s), 0);	// F[x+1, y+1]: Bottom Right
	float4 bc = rdRead.SampleLevel(_PointClamp, uv + float2( 0, +s), 0);	// F[x,   y+1]: Bottom Centre
	float4 cr = rdRead.SampleLevel(_PointClamp, uv + float2(+s,  0), 0);	// F[x+1, y  ]: Centre Right


	//float killRate = lerp(_MinKillRate, _MaxKillRate, i.uv.x);
	//float feedRate = lerp(_MinFeedRate, _MaxFeedRate, i.uv.y);
	//float killRate = lerp(_MinKillRate, _MaxKillRate, sin(_Time.y * 1.3437 - 2.5 + i.uv.x * 0.467 + i.uv.y * 5.312) * 0.5 + 0.5);
	//float feedRate = lerp(_MinFeedRate, _MaxFeedRate, cos(_Time.y * 0.52 + 1.1983 + i.uv.y * 0.35 - i.uv.x * 1.197) * 0.5 + 0.5);
	
	float4 altitudeSample = _AltitudeTex.SampleLevel(_PointClamp, uv + float2( 0,  0), 0);
	float altitude01 = altitudeSample.x;
	float altitudeMask = saturate((altitude01 - 0.55) * 10);

	float killRate = lerp(0.060, 0.064, sin(uv.x * 3.528 - _Time * 0.2872) * 0.5 + 0.5); // 0.062;
	float feedRate = lerp(0.052, 0.058, cos(uv.y * 1.328 + _Time * 1.0413) * 0.5 + 0.5); //0.055;
	float diffusionRateA = lerp(0.9, 1, frac(uv.x * 3.331 + _Time * 10));
    float diffusionRateB = lerp(0.26, 0.33, frac(uv.y * 2.0457 + _Time * 14.23));

	diffusionRateA *= altitudeMask * 0.25 + 0.75;
	diffusionRateB *= altitudeMask * 0.25 + 0.75;
	//killRate += saturate((altitude01 - 0.5) * 8) * 0.002;
		
	float coCenter = -1;
	float coAdjacent = 0.2;
	float coDiagonal = 0.05;

	float laplaceA = cc.x * coCenter +
						(cl.x + tc.x + cr.x + bc.x) * coAdjacent +
						(bl.x + tl.x + tr.x + br.x) * coDiagonal;
	float laplaceB = cc.y * coCenter +
						(cl.y + tc.y + cr.y + bc.y) * coAdjacent +
						(bl.y + tl.y + tr.y + br.y) * coDiagonal;
				
	float abb = cc.x * cc.y * cc.y;

	float valA = cc.x + (diffusionRateA * laplaceA - abb + feedRate * (1 - cc.x)) * deltaTime;
	float valB = cc.y + (diffusionRateB * laplaceB + abb - (killRate + feedRate) * cc.y) * deltaTime;

	
	valB -= altitudeMask;

	float4 col = float4(saturate(valA), saturate(valB), 0, 1); 
	
	rdWrite[id.xy] = col;
	
}

[numthreads(32,32,1)]
void CSAdvectRD (uint3 id : SV_DispatchThreadID)
{

	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);

	float2 uvSample = uvOrigin - _DeltaTime * _InvGridScale * VelocityRead.SampleLevel(_LinearClamp, uvOrigin, 0).xy * 0.75;
	float4 newDensity = rdRead.SampleLevel(_LinearClamp, uvSample, 0);

	// Handle SpiritBrush Here????
	float4 spiritBrushSample = _SpiritBrushTex.SampleLevel(_LinearClamp, uvSample, 0);

	float brushMagnitude = _SpiritBrushIntensity;
	float deltaBrush = _IsSpiritBrushOn * _SpiritBrushPosNeg * spiritBrushSample.x;
	newDensity.y = saturate(newDensity.y + deltaBrush * brushMagnitude);  // *** TEMPORARY!!! **** Decomposers removed from brushing
			
	rdWrite[id.xy] = newDensity;
	
}
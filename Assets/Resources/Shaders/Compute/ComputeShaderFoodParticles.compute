#pragma kernel CSMeasureInitCritterDistances
#pragma kernel CSReduceCritterDistances32
#pragma kernel CSEatSelectedFoodParticles
#pragma kernel CSCopyFoodParticlesBuffer
#pragma kernel CSSimFoodParticlesBuffer
#pragma kernel CSMeasureTotalFoodParticlesAmount
#pragma kernel CSRespawnFoodParticles
#pragma kernel CSReviveSelectFoodParticles

#include "Assets/Resources/Shaders/Inc/StructsCritterData.cginc"

struct FoodParticleData {
    int index;
	int critterIndex; // index of creature which swallowed this foodParticle
    float isSwallowed;   // 0 = normal, 1 = in critter's belly
    float digestedAmount;  // 0 = freshly eaten, 1 = fully dissolved/shrunk        
    float2 worldPos;
    float radius;
    float foodAmount;
    float active;
	float refactoryAge;
};

StructuredBuffer<CritterInitData> critterInitDataCBuffer;
StructuredBuffer<CritterSimData> critterSimDataCBuffer;

StructuredBuffer<FoodParticleData> foodParticlesRead;
RWStructuredBuffer<FoodParticleData> foodParticlesWrite;
RWTexture2D<float4> foodParticlesNearestCrittersRT;

RWStructuredBuffer<FoodParticleData> closestParticlesDataCBuffer;

StructuredBuffer<float> foodParticlesEatAmountsRead;
RWStructuredBuffer<float> foodParticlesEatAmountsCBuffer;

StructuredBuffer<int> selectRespawnFoodParticleIndicesCBuffer;

Texture2D<float4> critterDistancesRead; // used to reduce foodParticlesNearestCrittersRT down to minimum distances
RWTexture2D<float4> critterDistancesWrite;

Texture2D<float4> obstaclesRead;
Texture2D<float4> velocityRead;

Texture2D<float4> _SpawnDensityMap;

uniform float _RespawnFoodParticles;
uniform float _Time;
uniform float _MapSize;

uniform float _MinParticleSize;
uniform float _MaxParticleSize;
uniform float _ParticleNutrientDensity;

uniform float _FoodParticleRegrowthRate;

uniform float4 _FoodSprinklePos;
uniform float _FoodSprinkleRadius;

SamplerState _LinearClamp;
SamplerState _LinearRepeat;
SamplerState _PointClamp;
SamplerState _PointRepeat;

float rand(float2 co){   // OUTPUT is in [0,1] RANGE!!!
	return frac(sin(dot(co.xy ,float2(12.9898,78.233))) * 43758.5453);
}

[numthreads(1024,1,1)]
void CSMeasureInitCritterDistances (uint3 id : SV_DispatchThreadID)
{	
	int particleIndex = id.x;
	int critterIndex = id.y;

	FoodParticleData particleData = foodParticlesRead[particleIndex];
	CritterInitData critterInitData = critterInitDataCBuffer[critterIndex];
	CritterSimData critterSimData = critterSimDataCBuffer[critterIndex];

	float mouthRadius = critterInitData.boundingBoxSize.x * critterSimData.growthPercentage; // **** REMEMBER TO *0.5 EVENTUALLY FOR ACCURATE SIZE
	float2 mouthCenterPos = critterSimData.heading * critterInitData.boundingBoxSize.y * 0.5 * critterSimData.growthPercentage;

	float2 particleToCritter = critterSimData.worldPos.xy + mouthCenterPos * 1.0 - particleData.worldPos;

	float distanceSquared = particleToCritter.x * particleToCritter.x + particleToCritter.y * particleToCritter.y;

	//if(particleData.radius > mouthRadius) {
	//	distanceSquared = 10000;
	//}

	foodParticlesNearestCrittersRT[int2(particleIndex, critterIndex)] = float4(particleData.index, distanceSquared, particleData.worldPos);
}

[numthreads(1,1,1)]
void CSReduceCritterDistances32 (uint3 id : SV_DispatchThreadID)
{	
	
	int critterIndex = id.y;

	//CritterInitData critterInitData = critterInitDataCBuffer[critterIndex];
	CritterSimData critterSimData = critterSimDataCBuffer[critterIndex];
			
	float closestParticleIndex = 0;
	float minSquaredDistance = 10000;
		
	for(int i = 0; i < 32; i++) {
		
		int particleIndex = id.x * 32 + i;
		
		float4 sourceData = critterDistancesRead[int2(particleIndex, critterIndex)];
		
		FoodParticleData particleData = foodParticlesRead[particleIndex];

		if(sourceData.y < minSquaredDistance) {
			if(particleData.active > 0.5) {
				minSquaredDistance = sourceData.y;
				closestParticleIndex = sourceData.x;
			}

			//if(particleData.radius < critterInitData.boundingBoxSize.x * critterSimData.growthPercentage) {
			//}					
		}
	}
		
	FoodParticleData closestFoodData = foodParticlesRead[closestParticleIndex];
	
	critterDistancesWrite[int2(id.x, critterIndex)] = float4(closestParticleIndex, minSquaredDistance, 1.0, 1.0);
	closestParticlesDataCBuffer[critterIndex] = closestFoodData; // assuming there's only 1 thread at end
}


[numthreads(1,1,1)]
void CSEatSelectedFoodParticles (uint3 id : SV_DispatchThreadID)
{	
	// Check distance to nearest particle
	int critterIndex = id.x;

	float4 data = critterDistancesRead[int2(0, id.x)];

	int particleIndex = (int)data.x;

	FoodParticleData particleData = foodParticlesRead[particleIndex];
	foodParticlesWrite[particleIndex] = particleData;

	CritterInitData critterInitData = critterInitDataCBuffer[critterIndex];
	CritterSimData critterSimData = critterSimDataCBuffer[critterIndex];

	float eatenAmount = 0.0;

	float distanceSquared = data.y;
	float mouthRadius = critterInitData.boundingBoxSize.x * critterSimData.growthPercentage;  // **** REMEMBER TO *0.5 EVENTUALLY FOR ACCURATE SIZE
	float particleRadius = particleData.radius;
	float combinedRadius = mouthRadius + particleRadius;

	if(distanceSquared < combinedRadius * combinedRadius) {		
		//if(mouthRadius > particleRadius) {
			//if(critterSimData.isBiting > 0.5) {
				eatenAmount = particleData.foodAmount;
			
				//foodParticlesCBuffer[particleIndex].foodAmount = 0;  // can;'t read & write to same buffer at same time !!! *** REMEMBER ***
			
				foodParticlesWrite[particleIndex].foodAmount = 0;
				foodParticlesWrite[particleIndex].active = 0;

				// NEW:
				foodParticlesWrite[particleIndex].isSwallowed = 1.0;
				foodParticlesWrite[particleIndex].digestedAmount = 0.0;
				foodParticlesWrite[particleIndex].critterIndex = critterIndex;

			//}			
		//}
	}	

	foodParticlesEatAmountsCBuffer[id.x] = eatenAmount;
}

[numthreads(1024,1,1)]
void CSCopyFoodParticlesBuffer (uint3 id : SV_DispatchThreadID)
{	
	FoodParticleData particleData = foodParticlesRead[id.x];
	
	foodParticlesWrite[id.x] = particleData;
}

[numthreads(1024,1,1)]
void CSSimFoodParticlesBuffer (uint3 id : SV_DispatchThreadID)
{	
	FoodParticleData particleData = foodParticlesRead[id.x];

	
	
	foodParticlesWrite[id.x] = particleData;
}

[numthreads(1,1,1)]
void CSMeasureTotalFoodParticlesAmount (uint3 id : SV_DispatchThreadID)
{	
	FoodParticleData copyData = foodParticlesRead[id.x];
	
	float totalFoodAmount = 0;
	
	for(int i = 0; i < 32; i++) {		
		int particleIndex = id.x * 32 + i;		
		FoodParticleData particleData = foodParticlesRead[particleIndex];				
		totalFoodAmount += particleData.foodAmount;
	}

	copyData.foodAmount = totalFoodAmount;
	
	foodParticlesWrite[id.x] = copyData;

	//=================== OLD ==================================================================
	/*float totalFoodAmount = 0;

	FoodParticleData newData;
	newData.index = 0;
	newData.worldPos = float2(0,0);
	newData.radius = 0.1;
	newData.active = 1;

	int totalIndex = 0;

	for(int i = 0; i < 32; i++) {
		
		int particleIndex = id.x * 32 + i;
		
		FoodParticleData particleData = foodParticlesRead[particleIndex];
		newData.foodAmount = 0.4; //particleData.foodAmount;
		totalIndex += particleData.index;
		totalFoodAmount += particleData.foodAmount;
	}
	newData.index = totalIndex;
	newData.foodAmount = totalFoodAmount;

	newData.refactoryAge = 0; // ***** Might cause problems? **
	newData.isSwallowed = 0;
	newData.critterIndex = 0;
	newData.digestedAmount = 0;
	
	foodParticlesWrite[id.x] = copyData; //newData;
	*/
}

[numthreads(1024,1,1)]
void CSRespawnFoodParticles (uint3 id : SV_DispatchThreadID)
{
	// Check if particle isn't in the water:

	FoodParticleData foodParticle = foodParticlesRead[id.x];
	
	float2 uv = foodParticle.worldPos / _MapSize;

	

	if(foodParticle.active > 0.5) {
		float obstacleValue = obstaclesRead.SampleLevel(_LinearClamp, uv, 2).z;
		if(obstacleValue > 0.01) {
			float randX = rand(float2((float)id.x, _Time * 100));
			float randY = rand(float2(randX, (float)id.x));
			foodParticlesWrite[id.x].worldPos = float2(randX * _MapSize, randY * _MapSize);
			foodParticlesWrite[id.x].active = 1.0;

			// Respawn if on land ^^^:
		}
		else {  // Otherwise simulate as normal
			
			
			float2 vel = velocityRead.SampleLevel(_LinearRepeat, uv, 2).xy;
			float speedMult = 0.01;				
			float2 nextPos = uv + vel * speedMult;

			float2 defaultNextPos = nextPos * _MapSize;
			
			foodParticlesWrite[id.x].worldPos = defaultNextPos; //lerp(defaultNextPos, swallowedPos, foodParticle.isSwallowed);		
		}
	}
	else {  // INACTIVE:::
		foodParticlesWrite[id.x].refactoryAge = foodParticle.refactoryAge + _FoodParticleRegrowthRate;

		//foodParticle.critterIndex
		float2 swallowedPos = critterSimDataCBuffer[foodParticle.critterIndex].worldPos.xy;
					
		foodParticlesWrite[id.x].worldPos = swallowedPos;

		foodParticlesWrite[id.x].digestedAmount = saturate(foodParticle.digestedAmount + 0.0075);
	}
	
	

	if(_RespawnFoodParticles > 0.5) {		
		
		if(foodParticlesRead[id.x].refactoryAge > 1.0) {
			
			float rand01 = rand(float2(_Time + foodParticlesRead[id.x].index, _Time));
			float randX = rand(float2((float)id.x, _Time));
			float randY = rand(float2(randX, (float)id.x));

			float2 spawnUV = float2(randX, randY);
			
			float4 spawnDensitySample = _SpawnDensityMap.SampleLevel(_LinearClamp, spawnUV, 0);

			float spawnThreshold = 0.0005;
			if(rand01 < 0.01) {  // to prevent mass respawning, overshooting the intended max global food amount ?
				if(spawnDensitySample.x > spawnThreshold) {
				
					foodParticlesWrite[id.x].worldPos = float2(randX * _MapSize, randY * _MapSize);

					float randRadius = rand(float2(randX * 10, randY * -3.37)) * (_MaxParticleSize - _MinParticleSize) + _MinParticleSize;
					foodParticlesWrite[id.x].radius = randRadius;
					foodParticlesWrite[id.x].foodAmount = randRadius * randRadius * 3.141592 * _ParticleNutrientDensity;
					foodParticlesWrite[id.x].active = 1.0;
					foodParticlesWrite[id.x].refactoryAge = 0.0;
					foodParticlesWrite[id.x].isSwallowed = 0.0;
					foodParticlesWrite[id.x].digestedAmount = 0.0;
				}			
			}			
		}		
	}
}


[numthreads(1,1,1)]
void CSReviveSelectFoodParticles (uint3 id : SV_DispatchThreadID)
{
	int particleIndex = selectRespawnFoodParticleIndicesCBuffer[id.x];
		
	float rand01 = rand(float2(_Time + foodParticlesRead[particleIndex].index, _Time));
	float randX = _FoodSprinklePos.x; //rand(float2((float)particleIndex, _Time));
	float randY = _FoodSprinklePos.y; //rand(float2(randX, (float)particleIndex));

	float randOffsetX = rand(float2((float)particleIndex, _Time)) - 0.5;
	float randOffsetY = rand(float2(randX, (float)particleIndex)) - 0.5;

	float2 randOffset = float2(randOffsetX, randOffsetY) * _FoodSprinkleRadius * 0.01;

	float2 spawnUV = float2(randX, randY) + randOffset;
				
	foodParticlesWrite[particleIndex].worldPos = spawnUV * _MapSize;

	float randRadius = rand(float2((float)id.x * 10, randY * -3.37)) * (_MaxParticleSize - _MinParticleSize) + _MinParticleSize;
	foodParticlesWrite[particleIndex].radius = randRadius;
	foodParticlesWrite[particleIndex].foodAmount = randRadius * randRadius * 3.141592 * _ParticleNutrientDensity;
	foodParticlesWrite[particleIndex].active = 1.0;
	foodParticlesWrite[particleIndex].refactoryAge = 0.0;
	foodParticlesWrite[particleIndex].isSwallowed = 0.0;
	foodParticlesWrite[particleIndex].digestedAmount = 0.0;
				
}
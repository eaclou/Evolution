// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel RefreshColor
#pragma kernel InitializeVelocity
#pragma kernel Advection
#pragma kernel ViscousDiffusion
#pragma kernel ExternalForce
#pragma kernel VelocityInjectionPoints
#pragma kernel VelocityInjectionTexture
#pragma kernel VelocityDivergence
#pragma kernel PressureJacobi
#pragma kernel SubtractGradient


struct ForcePoint {
    float posX;
    float posY;        
    float velX;
    float velY;
    float size;
};

Texture2D<float4> SourceColorTex;
Texture2D<float4> InputVelocityTex;
StructuredBuffer<ForcePoint> ForcePointsCBuffer;
Texture2D<float4> VelocityRead;
RWTexture2D<float4> VelocityWrite;
Texture2D<float4> PressureRead;
RWTexture2D<float4> PressureWrite;
Texture2D<float4> DensityRead;
RWTexture2D<float4> DensityWrite;
Texture2D<float4> DivergenceRead;
RWTexture2D<float4> DivergenceWrite;
Texture2D<float4> ObstaclesRead;

SamplerState _LinearClamp;
SamplerState _LinearRepeat;
SamplerState _PointClamp;
SamplerState _PointRepeat;

uniform float _TextureResolution;
uniform float _DeltaTime;
uniform float _InvGridScale;

uniform float _ForcePosX;
uniform float _ForcePosY;
uniform float _ForceDirX;
uniform float _ForceDirY;
uniform float _ForceOn;
uniform float _ForceMagnitude;
uniform float _ForceSize;

uniform float _Viscosity;
uniform float _Damping;

uniform float _ColorRefreshAmount;

uniform float _Time;

[numthreads(16,16,1)]
void RefreshColor (uint3 id : SV_DispatchThreadID)
{	
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float4 sourceColor = SourceColorTex.SampleLevel(_LinearRepeat, uvOrigin, 0);
	float4 currentColor = DensityRead[id.xy];
	DensityWrite[id.xy] = lerp(currentColor, sourceColor, _ColorRefreshAmount);
}

[numthreads(16,16,1)]
void InitializeVelocity (uint3 id : SV_DispatchThreadID)
{
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);

	VelocityWrite[id.xy] = float4(sin(20 * uvOrigin.y) * uvOrigin.x,sin(13.79 * uvOrigin.x) * uvOrigin.y,0,0) * 0.2; // 
}

[numthreads(16,16,1)]
void Advection (uint3 id : SV_DispatchThreadID)
{

	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);

	float isSolid = ObstaclesRead[id.xy].r;
	if(isSolid > 0.5) {
		//DensityWrite[id.xy] = float4(0,0,0,0);
		VelocityWrite[id.xy] = float4(0,0,0,0);

		return;
	}

	float2 uvSample = uvOrigin - _DeltaTime * _InvGridScale * VelocityRead.SampleLevel(_LinearRepeat, uvOrigin, 0).xy;
	
	float4 newDensity = DensityRead.SampleLevel(_LinearRepeat, uvSample, 0);
	float4 newVelocity = VelocityRead.SampleLevel(_LinearRepeat, uvSample, 0);
		
	DensityWrite[id.xy] = newDensity;
	VelocityWrite[id.xy] = newVelocity; // + float4(uvSample, 0, 0);
}

[numthreads(16,16,1)]
void ViscousDiffusion (uint3 id : SV_DispatchThreadID)
{
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float ps = 1.0 / _TextureResolution;

	half viscosity = _Viscosity;

	half alpha = (_InvGridScale * _InvGridScale) / (viscosity * _DeltaTime);
	half beta = 4.0 + alpha;

	half4 leftVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0);
	half4 rightVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0);
	half4 topVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0);
	half4 bottomVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0);
	half4 centerVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin, 0);

	float4 newVal = (leftVal + rightVal + topVal + bottomVal + centerVal * alpha) / beta;

	VelocityWrite[id.xy] = newVal;
}

[numthreads(16,16,1)]
void VelocityInjectionPoints (uint3 id : SV_DispatchThreadID)
{	
	float isSolid = ObstaclesRead[id.xy].r;
	if(isSolid > 0.5) {
		VelocityWrite[id.xy] = float4(0,0,0,0);
		return;
	}
	
	uint elements;
	uint stride;
	ForcePointsCBuffer.GetDimensions(elements, stride);

	float xCoord = ((float)id.x + 0.5) / _TextureResolution;
	float yCoord = ((float)id.y + 0.5) / _TextureResolution;
	float2 pixelCoords = float2(xCoord, yCoord);
	
	float4 currentVelocity = VelocityRead[id.xy];
	
	float2 newForce = currentVelocity.xy; //float2(0,0);

	//float influenceAmount = 0;
	for(uint i = 0; i < elements; i++) {
		
		ForcePoint fp;
		fp = ForcePointsCBuffer[i];	

		float2 forceCoords = float2(fp.posX, fp.posY);
		float2 forceVal = float2(fp.velX, fp.velY);		
		float dist = length(pixelCoords - forceCoords);
		float influenceAmount = exp(-fp.size * ((forceCoords.x - pixelCoords.x) * (forceCoords.x - pixelCoords.x) + (forceCoords.y - pixelCoords.y) * (forceCoords.y - pixelCoords.y)) / dist);
		//newForce += forceVal * _DeltaTime * ;
		newForce = lerp(newForce, forceVal, influenceAmount);
	}
	float damping = saturate(_Damping);
	float2 constantVel = float2(0.005, 0.03) * 0;
	VelocityWrite[id.xy] = float4(newForce + constantVel, 0, 0) * (1.0 - damping);  //(currentVelocity + float4(newForce, 0, 0)) * (1.0 - damping);  //lerp(currentVelocity, float4(newForce, 0, 0) * 20, 1);
}
[numthreads(16,16,1)]
void VelocityInjectionTexture (uint3 id : SV_DispatchThreadID)
{	
	
}

[numthreads(16,16,1)]
void ExternalForce (uint3 id : SV_DispatchThreadID)
{
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float ps = 1.0 / _TextureResolution;

	float4 currentVelocity = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin, 0);

	float2 clickPos = float2(_ForcePosX, _ForcePosY);
	float2 clickDir = float2(_ForceDirX, _ForceDirY);
	//float forceMagnitude = _;

	float dist = length(uvOrigin - clickPos);

	//float falloff = 1.0 / dist;
	//float2 velocityAdd = float2(0, 0);
	//if(dist < 0.02) {
	//	velocityAdd = float2(sin(_Time * 0.1) * 0.03, cos(_Time * 0.1) * 0.03);
	//}

	float2 velocityAdd = _ForceOn * clickDir * _ForceMagnitude * _DeltaTime * exp(-_ForceSize * ((_ForcePosX - uvOrigin.x) * (_ForcePosX - uvOrigin.x) + (_ForcePosY - uvOrigin.y) * (_ForcePosY - uvOrigin.y)) / dist);

	float damping = saturate(_Damping);
	VelocityWrite[id.xy] = (currentVelocity + float4(velocityAdd, 0, 0)) * (1.0 - damping);
}

[numthreads(16,16,1)]
void VelocityDivergence (uint3 id : SV_DispatchThreadID)
{
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float ps = 1.0 / _TextureResolution;

	float4 leftVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0);  // should I use direct index access for these?
	float4 rightVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0);
	float4 topVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0);
	float4 bottomVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0);

	// See Below %%% v v v %%% IF I ADD DYNAMIC OBSTACLES:::  But if I assume they are static then neighbor vel will always be 0 which it should be anyway after Advection etc. ???
	// ..... Come back to this later.....
	// Find neighboring obstacles:
    // vec3 oN = texelFetchOffset(Obstacles, T, 0, ivec2(0, 1)).xyz;
    // vec3 oS = texelFetchOffset(Obstacles, T, 0, ivec2(0, -1)).xyz;
    // vec3 oE = texelFetchOffset(Obstacles, T, 0, ivec2(1, 0)).xyz;
    // vec3 oW = texelFetchOffset(Obstacles, T, 0, ivec2(-1, 0)).xyz;
    // Use obstacle velocities for solid cells:
    // if (oN.x > 0) vN = oN.yz;
    // if (oS.x > 0) vS = oS.yz;
    // if (oE.x > 0) vE = oE.yz;
    // if (oW.x > 0) vW = oW.yz;
	//////////////////////////////////////////////////

	float divergence = _InvGridScale * 0.5 * ((rightVal.x - leftVal.x) + (topVal.y - bottomVal.y));

	DivergenceWrite[id.xy] = float4(divergence, divergence, divergence, 1);
}

[numthreads(16,16,1)]
void PressureJacobi (uint3 id : SV_DispatchThreadID)
{
	//float isSolid = saturate(ceil(ObstaclesRead[id.xy].r));

	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float ps = 1.0 / _TextureResolution;
	
	half alpha = -(_InvGridScale * _InvGridScale);
	half beta = 4.0;

	half4 leftObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0);
	half4 rightObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0);
	half4 topObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0);
	half4 bottomObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0);
		
	half4 centerPressure = PressureRead[id.xy];
	half4 leftPressure = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0);
	half4 rightPressure = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0);
	half4 topPressure = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0);
	half4 bottomPressure = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0);

	if(leftObstacle.x > 0.5) leftPressure = centerPressure;
	if(rightObstacle.x > 0.5) rightPressure = centerPressure;
	if(topObstacle.x > 0.5) topPressure = centerPressure;
	if(bottomObstacle.x > 0.5) bottomPressure = centerPressure;

	half4 divergence = DivergenceRead.SampleLevel(_LinearRepeat, uvOrigin, 0);
	float4 newPressure = (leftPressure + rightPressure + topPressure + bottomPressure + divergence * alpha) / beta;
	PressureWrite[id.xy] = newPressure;
}

[numthreads(16,16,1)]
void SubtractGradient (uint3 id : SV_DispatchThreadID)
{
	float isSolid = ObstaclesRead[id.xy].r;
	if (isSolid > 0.5) {
        VelocityWrite[id.xy] = float4(0,0,0,0);  // <-- If I add moving obstacles, revisit this!!
        return;
    }

	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float ps = 1.0 / _TextureResolution;
	
	float centerPressure = PressureRead[id.xy].x;
	float leftPressure = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0).x;
	float rightPressure = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0).x;
	float topPressure = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0).x;
	float bottomPressure = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0).x;

	half4 leftObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0);
	half4 rightObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0);
	half4 topObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0);
	half4 bottomObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0);
	
	if(leftObstacle.x > 0.5) leftPressure = centerPressure;
	if(rightObstacle.x > 0.5) rightPressure = centerPressure;
	if(topObstacle.x > 0.5) topPressure = centerPressure;
	if(bottomObstacle.x > 0.5) bottomPressure = centerPressure;
	
	float4 newVelocity = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin, 0);
	newVelocity.xy -= 0.5 * _InvGridScale * half2(rightPressure - leftPressure, topPressure - bottomPressure);

	VelocityWrite[id.xy] = newVelocity;
}



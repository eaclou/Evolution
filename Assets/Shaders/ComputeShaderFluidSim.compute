// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel RefreshColor
#pragma kernel InitializeVelocity
#pragma kernel Advection
#pragma kernel ViscousDiffusion
#pragma kernel ExternalForce
#pragma kernel EnforceBoundariesVelocity
#pragma kernel VelocityInjectionPoints
#pragma kernel VelocityInjectionTexture
#pragma kernel VelocityDivergence
#pragma kernel InitializePressure
#pragma kernel PressureJacobi
#pragma kernel SubtractGradient


struct ForcePoint {
    float posX;
    float posY;        
    float velX;
    float velY;
    float size;
};

Texture2D<float4> SourceColorTex;
Texture2D<float4> InputVelocityTex;
StructuredBuffer<ForcePoint> ForcePointsCBuffer;
Texture2D<float4> VelocityRead;
RWTexture2D<float4> VelocityWrite;
Texture2D<float4> PressureRead;
RWTexture2D<float4> PressureWrite;
Texture2D<float4> DensityRead;
RWTexture2D<float4> DensityWrite;
Texture2D<float4> DivergenceRead;
RWTexture2D<float4> DivergenceWrite;
Texture2D<float4> ObstaclesRead;

SamplerState _LinearClamp;
SamplerState _LinearRepeat;
SamplerState _PointClamp;
SamplerState _PointRepeat;

uniform float _TextureResolution;
uniform float _DeltaTime;
uniform float _InvGridScale;

uniform float _ForcePosX;
uniform float _ForcePosY;
uniform float _ForceDirX;
uniform float _ForceDirY;
uniform float _ForceOn;
uniform float _ForceMagnitude;
uniform float _ForceSize;

uniform float _Viscosity;
uniform float _Damping;

uniform float _ColorRefreshAmount;

uniform float _Time;

[numthreads(16,16,1)]
void RefreshColor (uint3 id : SV_DispatchThreadID)
{	
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float4 sourceColor = SourceColorTex.SampleLevel(_LinearRepeat, uvOrigin, 0);
	float4 currentColor = DensityRead[id.xy];
	DensityWrite[id.xy] = lerp(currentColor, sourceColor, _ColorRefreshAmount);
}

[numthreads(16,16,1)]
void InitializeVelocity (uint3 id : SV_DispatchThreadID)
{
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);

	VelocityWrite[id.xy] = float4(sin(20 * uvOrigin.y) * uvOrigin.x,sin(13.79 * uvOrigin.x) * uvOrigin.y,0,0) * 0.1; // 
}

[numthreads(16,16,1)]
void Advection (uint3 id : SV_DispatchThreadID)
{
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);

	float2 uvSample = uvOrigin - _DeltaTime * _InvGridScale * VelocityRead.SampleLevel(_LinearRepeat, uvOrigin, 0).xy;
	//uvSample = uvOrigin;

	float4 newDensity = DensityRead.SampleLevel(_LinearRepeat, uvSample, 0);
	float4 newVelocity = VelocityRead.SampleLevel(_LinearRepeat, uvSample, 0);
		
	DensityWrite[id.xy] = newDensity;
	VelocityWrite[id.xy] = newVelocity; // + float4(uvSample, 0, 0);
}

[numthreads(16,16,1)]
void ViscousDiffusion (uint3 id : SV_DispatchThreadID)
{
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float ps = 1.0 / _TextureResolution;

	half viscosity = _Viscosity;

	half alpha = (_InvGridScale * _InvGridScale) / (viscosity * _DeltaTime);
	half beta = 4.0 + alpha;

	half4 leftVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0);
	half4 rightVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0);
	half4 topVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0);
	half4 bottomVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0);
	half4 centerVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin, 0);

	float4 newVal = (leftVal + rightVal + topVal + bottomVal + centerVal * alpha) / beta;

	VelocityWrite[id.xy] = newVal;
}

[numthreads(16,16,1)]
void VelocityInjectionPoints (uint3 id : SV_DispatchThreadID)
{	
	uint elements;
	uint stride;
	ForcePointsCBuffer.GetDimensions(elements, stride);

	float xCoord = ((float)id.x + 0.5) / _TextureResolution;
	float yCoord = ((float)id.y + 0.5) / _TextureResolution;
	float2 pixelCoords = float2(xCoord, yCoord);
	
	float4 currentVelocity = VelocityRead[id.xy];
	
	float2 newForce = currentVelocity.xy; //float2(0,0);

	//float influenceAmount = 0;
	for(uint i = 0; i < elements; i++) {
		
		ForcePoint fp;
		fp = ForcePointsCBuffer[i];	

		float2 forceCoords = float2(fp.posX, fp.posY);
		float2 forceVal = float2(fp.velX, fp.velY);		
		float dist = length(pixelCoords - forceCoords);
		float influenceAmount = exp(-fp.size * ((forceCoords.x - pixelCoords.x) * (forceCoords.x - pixelCoords.x) + (forceCoords.y - pixelCoords.y) * (forceCoords.y - pixelCoords.y)) / dist);
		//newForce += forceVal * _DeltaTime * ;
		newForce = lerp(newForce, forceVal, influenceAmount);
	}
	float damping = saturate(_Damping);

	VelocityWrite[id.xy] = float4(newForce, 0, 0) * (1.0 - damping);  //(currentVelocity + float4(newForce, 0, 0)) * (1.0 - damping);  //lerp(currentVelocity, float4(newForce, 0, 0) * 20, 1);
}
[numthreads(16,16,1)]
void VelocityInjectionTexture (uint3 id : SV_DispatchThreadID)
{	
	
}

[numthreads(16,16,1)]
void ExternalForce (uint3 id : SV_DispatchThreadID)
{
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float ps = 1.0 / _TextureResolution;

	float4 currentVelocity = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin, 0);

	float2 clickPos = float2(_ForcePosX, _ForcePosY);
	float2 clickDir = float2(_ForceDirX, _ForceDirY);
	//float forceMagnitude = _;

	float dist = length(uvOrigin - clickPos);

	//float falloff = 1.0 / dist;
	//float2 velocityAdd = float2(0, 0);
	//if(dist < 0.02) {
	//	velocityAdd = float2(sin(_Time * 0.1) * 0.03, cos(_Time * 0.1) * 0.03);
	//}

	float2 velocityAdd = _ForceOn * clickDir * _ForceMagnitude * _DeltaTime * exp(-_ForceSize * ((_ForcePosX - uvOrigin.x) * (_ForcePosX - uvOrigin.x) + (_ForcePosY - uvOrigin.y) * (_ForcePosY - uvOrigin.y)) / dist);

	float damping = saturate(_Damping);
	VelocityWrite[id.xy] = (currentVelocity + float4(velocityAdd, 0, 0)) * (1.0 - damping);
}

[numthreads(16,16,1)]
void EnforceBoundariesVelocity (uint3 id : SV_DispatchThreadID)
{	
	half4 centerVal = ObstaclesRead[id.xy];
	float obstacleMask = round(centerVal.x);

	if(obstacleMask > 0.5) {
		
	
		float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
		float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
		float2 uvOrigin = float2(xCoord, yCoord);
		float ps = 1.0 / _TextureResolution;
	
		half4 leftVal = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0);
		half4 rightVal = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0);
		half4 topVal = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0);
		half4 bottomVal = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0);
	
	
		float dX = (rightVal.x - centerVal.x + centerVal.x - leftVal.x) * 0.5;
		float dY = (topVal.y - centerVal.y + centerVal.y - bottomVal.y) * 0.5;
		float2 normalDir = normalize(float2(dX, dY));

		float2 neighborCoords = uvOrigin + normalDir * ps;
		float4 neighborVelocity = VelocityRead.SampleLevel(_LinearRepeat, neighborCoords, 0);
		float neighborMask = ObstaclesRead.SampleLevel(_LinearRepeat, neighborCoords, 0);

		float innerObstacleMask = obstacleMask * round(neighborMask);  // 1 if inner, 0 if border
		VelocityWrite[id.xy] = lerp(float4(-neighborVelocity.xy,0,0), float4(neighborVelocity.xy,0,0), innerObstacleMask);	
	}
	else {
		float4 currentVelocityVal = VelocityRead[id.xy];
		VelocityWrite[id.xy] = currentVelocityVal;
	}
}

[numthreads(16,16,1)]
void VelocityDivergence (uint3 id : SV_DispatchThreadID)
{
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float ps = 1.0 / _TextureResolution;

	float4 leftVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0);  // should I use direct index access for these?
	float4 rightVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0);
	float4 topVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0);
	float4 bottomVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0);

	float divergence = _InvGridScale * 0.5 * ((rightVal.x - leftVal.x) + (topVal.y - bottomVal.y));

	DivergenceWrite[id.xy] = float4(divergence, divergence, divergence, 1);
}

[numthreads(16,16,1)]
void InitializePressure (uint3 id : SV_DispatchThreadID)
{
	PressureWrite[id.xy] = float4(0,0,0,0);
}

[numthreads(16,16,1)]
void PressureJacobi (uint3 id : SV_DispatchThreadID)
{
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float ps = 1.0 / _TextureResolution;
	
	half alpha = -(_InvGridScale * _InvGridScale);
	half beta = 4.0;

	half4 leftVal = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0);
	half4 rightVal = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0);
	half4 topVal = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0);
	half4 bottomVal = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0);
	half4 centerVal = DivergenceRead.SampleLevel(_LinearRepeat, uvOrigin, 0);

	float4 newVal = (leftVal + rightVal + topVal + bottomVal + centerVal * alpha) / beta;

	half4 leftObstacles = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps * 2, 0), 1);
	half4 rightObstacles = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps * 2, 0), 1);
	half4 topObstacles = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps * 2), 1);
	half4 bottomObstacles = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps * 2), 1);
	half4 centerObstacles = ObstaclesRead[id.xy];
	float obstacleMask = centerObstacles.x;
	
	float dX = (rightObstacles.x - centerObstacles.x + centerObstacles.x - leftObstacles.x) * 0.5;
	float dY = (topObstacles.y - centerObstacles.y + centerObstacles.y - bottomObstacles.y) * 0.5;
	float2 normalDir = normalize(float2(dX, dY));

	float2 neighborCoords = uvOrigin + normalDir * ps;
	float4 neighborPressure = PressureRead.SampleLevel(_LinearRepeat, neighborCoords, 0);

	PressureWrite[id.xy] = lerp(newVal, neighborPressure, round(obstacleMask));
}

[numthreads(16,16,1)]
void SubtractGradient (uint3 id : SV_DispatchThreadID)
{
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float ps = 1.0 / _TextureResolution;
	
	float leftVal = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0).x;
	float rightVal = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0).x;
	float topVal = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0).x;
	float bottomVal = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0).x;
	
	float4 newVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin, 0);
	newVal.xy -= 0.5 * _InvGridScale * half2(rightVal - leftVal, topVal - bottomVal);

	VelocityWrite[id.xy] = newVal;
}



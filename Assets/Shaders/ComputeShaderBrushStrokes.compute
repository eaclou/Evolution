// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSInitializeCurveBrushData
#pragma kernel CSIterateCurveBrushData

struct AgentSimData {
	float2 worldPos;
	float2 velocity;
	float2 heading;
	float2 size;
};

struct CurveStrokeData {
    int parentIndex;
    float3 hue;
    float2 p0;
    float2 p1;
    float2 p2;
    float2 p3;
};

StructuredBuffer<AgentSimData> agentSimDataCBuffer;
StructuredBuffer<int> agentInitializeCBuffer;
StructuredBuffer<CurveStrokeData> agentCurveStrokesReadCBuffer;
RWStructuredBuffer<CurveStrokeData> agentCurveStrokesWriteCBuffer;

[numthreads(1,1,1)]
void CSInitializeCurveBrushData (uint3 id : SV_DispatchThreadID)
{
	int agentIndex = agentInitializeCBuffer[id.x];	
	AgentSimData agentdata = agentSimDataCBuffer[agentIndex];
	
	float restDistance = 0.33;

	agentCurveStrokesWriteCBuffer[agentIndex].p0 = agentdata.worldPos; // pin root

	float2 targetPosP1 = agentdata.worldPos - agentdata.heading * restDistance;
	agentCurveStrokesWriteCBuffer[agentIndex].p1 = targetPosP1;

	float2 targetPosP2 = targetPosP1 - agentdata.heading * restDistance;
	agentCurveStrokesWriteCBuffer[agentIndex].p2 = targetPosP2;

	float2 targetPosP3 = targetPosP2 - agentdata.heading * restDistance;
	agentCurveStrokesWriteCBuffer[agentIndex].p3 = targetPosP3;
}

[numthreads(1,1,1)]
void CSIterateCurveBrushData (uint3 id : SV_DispatchThreadID)
{
	CurveStrokeData oldCurveData = agentCurveStrokesReadCBuffer[id.x];
	AgentSimData agentdata = agentSimDataCBuffer[oldCurveData.parentIndex];
	
	float lerpStrength = 0.7;
	float lerpDecay = 0.6;
	float restDistance = 0.33;

	CurveStrokeData newCurveData;
	newCurveData.parentIndex = oldCurveData.parentIndex;
	newCurveData.hue = oldCurveData.hue;

	newCurveData.p0 = agentdata.worldPos + (agentdata.heading * agentdata.size.y); // pin root to head tip

	float2 targetPosP1 = newCurveData.p0 - agentdata.heading * restDistance;
	newCurveData.p1 = lerp(oldCurveData.p1, targetPosP1, lerpStrength);

	lerpStrength *= lerpDecay;

	float2 vec2to1 = oldCurveData.p2 - oldCurveData.p1;
	float2 targetPosP2 = oldCurveData.p1 - agentdata.heading * restDistance;
	newCurveData.p2 = lerp(oldCurveData.p2, targetPosP2, lerpStrength);

	lerpStrength *= lerpDecay;

	float2 vec3to2 = oldCurveData.p3 - oldCurveData.p2;
	float2 targetPosP3 = oldCurveData.p2 - agentdata.heading * restDistance;
	newCurveData.p3 = lerp(oldCurveData.p3, targetPosP3, lerpStrength);


	agentCurveStrokesWriteCBuffer[id.x] = newCurveData;
}

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel RefreshColor
#pragma kernel InitializeVelocity
#pragma kernel Advection
#pragma kernel ViscousDiffusion
#pragma kernel VelocityInjectionPoints
#pragma kernel VelocityDivergence
#pragma kernel PressureJacobi
#pragma kernel SubtractGradient

struct ForcePoint {
    float posX;
    float posY;        
    float velX;
    float velY;
    float size;
};

Texture2D<float4> SourceColorTex;
Texture2D<float4> InputVelocityTex;
StructuredBuffer<ForcePoint> ForcePointsCBuffer;
Texture2D<float4> VelocityRead;
RWTexture2D<float4> VelocityWrite;
Texture2D<float4> PressureRead;
RWTexture2D<float4> PressureWrite;
Texture2D<float4> DensityRead;
RWTexture2D<float4> DensityWrite;
Texture2D<float4> DivergenceRead;
RWTexture2D<float4> DivergenceWrite;
Texture2D<float4> ObstaclesRead;

SamplerState _LinearClamp;
SamplerState _LinearRepeat;
SamplerState _PointClamp;
SamplerState _PointRepeat;

uniform float _TextureResolution;
uniform float _DeltaTime;
uniform float _InvGridScale;

uniform float _ForcePosX;
uniform float _ForcePosY;
uniform float _ForceDirX;
uniform float _ForceDirY;
uniform float _ForceOn;
uniform float _ForceMagnitude;
uniform float _ForceSize;

uniform float _Viscosity;
uniform float _Damping;

uniform float _ColorRefreshAmount;

uniform float _Time;

[numthreads(16,16,1)]
void RefreshColor (uint3 id : SV_DispatchThreadID)
{	
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float4 sourceColor = SourceColorTex.SampleLevel(_LinearRepeat, uvOrigin, 0);
	float4 currentColor = DensityRead[id.xy];
	DensityWrite[id.xy] = lerp(currentColor, sourceColor, _ColorRefreshAmount);
}

[numthreads(16,16,1)]
void InitializeVelocity (uint3 id : SV_DispatchThreadID)
{
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);

	VelocityWrite[id.xy] = float4(sin(20 * uvOrigin.y) * uvOrigin.x,sin(13.79 * uvOrigin.x) * uvOrigin.y,0,0) * 0.2; // 
}

[numthreads(16,16,1)]
void Advection (uint3 id : SV_DispatchThreadID)
{

	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);

	float isSolid = ObstaclesRead[id.xy].b;	
	float2 uvSample = uvOrigin - _DeltaTime * _InvGridScale * VelocityRead.SampleLevel(_LinearRepeat, uvOrigin, 0).xy;
	float4 newDensity = DensityRead.SampleLevel(_LinearRepeat, uvSample, 0);

	if(isSolid > 0.5) {
		DensityWrite[id.xy] = newDensity;
		VelocityWrite[id.xy] = float4(0,0,0,0);

		return;
	}

	
	
	
	float4 newVelocity = VelocityRead.SampleLevel(_LinearRepeat, uvSample, 0);
		
	DensityWrite[id.xy] = newDensity;
	VelocityWrite[id.xy] = newVelocity * (1.0 - saturate(_Damping)); // + float4(uvSample, 0, 0);
}

[numthreads(16,16,1)]
void ViscousDiffusion (uint3 id : SV_DispatchThreadID)
{
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float ps = 1.0 / _TextureResolution;

	half viscosity = _Viscosity;

	half alpha = (_InvGridScale * _InvGridScale) / (viscosity * _DeltaTime);
	half beta = 4.0 + alpha;

	half4 leftVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0);
	half4 rightVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0);
	half4 topVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0);
	half4 bottomVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0);
	half4 centerVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin, 0);

	float4 newVal = (leftVal + rightVal + topVal + bottomVal + centerVal * alpha) / beta;

	VelocityWrite[id.xy] = newVal;
}

[numthreads(16,16,1)]
void VelocityInjectionPoints (uint3 id : SV_DispatchThreadID)
{	
	float isSolid = ObstaclesRead[id.xy].b;
	if(isSolid > 0.5) {
		VelocityWrite[id.xy] = float4(0,0,0,0);
		return;
	}
	
	uint elements;
	uint stride;
	ForcePointsCBuffer.GetDimensions(elements, stride);

	float xCoord = ((float)id.x + 0.5) / _TextureResolution;
	float yCoord = ((float)id.y + 0.5) / _TextureResolution;
	float2 pixelCoords = float2(xCoord, yCoord);
	
	float4 currentVelocity = VelocityRead[id.xy];
	
	float2 newForce = currentVelocity.xy; //float2(0,0);

	//float influenceAmount = 0;
	for(uint i = 0; i < elements; i++) {
		
		ForcePoint fp;
		fp = ForcePointsCBuffer[i];	

		float2 forceCoords = float2(fp.posX, fp.posY);
		float2 forceVal = float2(fp.velX, fp.velY);		
		float dist = length(pixelCoords - forceCoords);
		float influenceAmount = exp(-fp.size * ((forceCoords.x - pixelCoords.x) * (forceCoords.x - pixelCoords.x) + (forceCoords.y - pixelCoords.y) * (forceCoords.y - pixelCoords.y)) / dist);
		//newForce += forceVal * _DeltaTime * ;
		newForce = lerp(newForce, forceVal, influenceAmount);
	}
	float damping = saturate(_Damping);
	float2 constantVel = float2(0.005, 0.03) * 0.0;
	VelocityWrite[id.xy] = float4(newForce + constantVel, 0, 0) * (1.0 - damping);  //(currentVelocity + float4(newForce, 0, 0)) * (1.0 - damping);  //lerp(currentVelocity, float4(newForce, 0, 0) * 20, 1);
}

[numthreads(16,16,1)]
void VelocityDivergence (uint3 id : SV_DispatchThreadID)
{
	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float ps = 1.0 / _TextureResolution;

	float4 leftVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0);  // should I use direct index access for these?
	float4 rightVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0);
	float4 topVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0);
	float4 bottomVal = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0);

	half4 leftObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0);
	half4 rightObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0);
	half4 topObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0);
	half4 bottomObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0);

	if(leftObstacle.b > 0.5) leftVal.xy = leftObstacle.xy;
	if(rightObstacle.b > 0.5) rightVal.xy = rightObstacle.xy;
	if(topObstacle.b > 0.5) topVal.xy = topObstacle.xy;
	if(bottomObstacle.b > 0.5) bottomVal.xy = bottomObstacle.xy;
	
	float divergence = _InvGridScale * 0.5 * ((rightVal.x - leftVal.x) + (topVal.y - bottomVal.y));

	DivergenceWrite[id.xy] = float4(divergence, divergence, divergence, 1);
}

[numthreads(16,16,1)]
void PressureJacobi (uint3 id : SV_DispatchThreadID)
{
	//float isSolid = saturate(ceil(ObstaclesRead[id.xy].r));

	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float ps = 1.0 / _TextureResolution;
	
	half alpha = -(_InvGridScale * _InvGridScale);
	half beta = 4.0;

	half4 leftObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0);
	half4 rightObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0);
	half4 topObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0);
	half4 bottomObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0);
		
	half4 centerPressure = PressureRead[id.xy];
	half4 leftPressure = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0);
	half4 rightPressure = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0);
	half4 topPressure = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0);
	half4 bottomPressure = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0);

	if(leftObstacle.b > 0.5) leftPressure = centerPressure;
	if(rightObstacle.b > 0.5) rightPressure = centerPressure;
	if(topObstacle.b > 0.5) topPressure = centerPressure;
	if(bottomObstacle.b > 0.5) bottomPressure = centerPressure;

	half4 divergence = DivergenceRead.SampleLevel(_LinearRepeat, uvOrigin, 0);
	float4 newPressure = (leftPressure + rightPressure + topPressure + bottomPressure + divergence * alpha) / beta;
	PressureWrite[id.xy] = newPressure;
}

[numthreads(16,16,1)]
void SubtractGradient (uint3 id : SV_DispatchThreadID)
{
	float4 centerObstacle = ObstaclesRead[id.xy];
	if (centerObstacle.b > 0.5) {
        VelocityWrite[id.xy] = float4(centerObstacle.xy,0,0);
        return;
    }

	float xCoord = ((float)id.x + 0.5)  / _TextureResolution;
	float yCoord = ((float)id.y + 0.5)  / _TextureResolution;
	float2 uvOrigin = float2(xCoord, yCoord);
	float ps = 1.0 / _TextureResolution;
	
	float centerPressure = PressureRead[id.xy].x;
	float leftPressure = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0).x;
	float rightPressure = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0).x;
	float topPressure = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0).x;
	float bottomPressure = PressureRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0).x;

	half4 leftObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(-ps, 0), 0);
	half4 rightObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(ps, 0), 0);
	half4 topObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, ps), 0);
	half4 bottomObstacle = ObstaclesRead.SampleLevel(_LinearRepeat, uvOrigin + half2(0, -ps), 0);
	
	// Copied from internet example... still need to understand this better::::
	float2 obstV = float2(0,0);
	float2 vMask = float2(1,1);

	if(leftObstacle.b > 0.5) { leftPressure = centerPressure; obstV.x = leftObstacle.x; vMask.x = 0; }
	if(rightObstacle.b > 0.5) { rightPressure = centerPressure; obstV.x = rightObstacle.x; vMask.x = 0; }
	if(topObstacle.b > 0.5) { topPressure = centerPressure; obstV.y = topObstacle.y; vMask.y = 0; }
	if(bottomObstacle.b > 0.5) { bottomPressure = centerPressure; obstV.y = bottomObstacle.y; vMask.y = 0; }
	
	float4 newVelocity = VelocityRead.SampleLevel(_LinearRepeat, uvOrigin, 0);
	float2 grad = 0.5 * _InvGridScale * half2(rightPressure - leftPressure, topPressure - bottomPressure);
	newVelocity.xy -= grad;
	VelocityWrite[id.xy] = float4(newVelocity.xy * vMask + obstV, 0, 0);
}


